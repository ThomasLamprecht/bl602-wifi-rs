/* automatically generated by rust-bindgen 0.58.1 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const BL_OS_TRUE: u32 = 1;
pub const BL_OS_FALSE: u32 = 0;
pub const BL_OS_WAITING_FOREVER: u32 = 4294967295;
pub const BL_OS_NO_WAITING: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const WIFI_MGMR_SCAN_ITEMS_MAX: u32 = 50;
pub const WIFI_MGMR_PROFILES_MAX: u32 = 1;
pub const WIFI_MGMR_MQ_MSG_SIZE: u32 = 224;
pub const WIFI_MGMR_MQ_MSG_COUNT: u32 = 1;
pub const MAX_FIXED_CHANNELS_LIMIT: u32 = 14;
pub const WIFI_MGMR_CONNECT_IND_STAT_INFO_TYPE_IND_CONNECTION: u32 = 1;
pub const WIFI_MGMR_CONNECT_IND_STAT_INFO_TYPE_IND_DISCONNECTION: u32 = 2;
pub const WIFI_MGMR_PENDING_TASK_SCAN_BIT: u32 = 1;
pub const WIFI_MGMR_PENDING_TASK_IP_UPDATE_BIT: u32 = 2;
pub const WIFI_MGMR_PENDING_TASK_IP_GOT_BIT: u32 = 4;
pub const WIFI_MGMR_FEATURES_SCAN_SAVE_HIDDEN_SSID: u32 = 1;
pub const WIFI_MGMR_CONFIG_SCAN_ITEM_TIMEOUT: u32 = 15000;
pub const MAX_HOSTNAME_LEN_CHECK: u32 = 32;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_OFF: u32 = 1;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_ON: u32 = 2;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_DYNAMIC_ON: u32 = 3;
pub type va_list = *mut crate::binary::c_types::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut crate::binary::c_types::c_char, ...);
}
pub type size_t = crate::binary::c_types::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = crate::binary::c_types::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = crate::binary::c_types::c_schar;
pub type int_least16_t = crate::binary::c_types::c_short;
pub type int_least32_t = crate::binary::c_types::c_int;
pub type int_least64_t = crate::binary::c_types::c_longlong;
pub type uint_least8_t = crate::binary::c_types::c_uchar;
pub type uint_least16_t = crate::binary::c_types::c_ushort;
pub type uint_least32_t = crate::binary::c_types::c_uint;
pub type uint_least64_t = crate::binary::c_types::c_ulonglong;
pub type int_fast8_t = crate::binary::c_types::c_schar;
pub type int_fast16_t = crate::binary::c_types::c_int;
pub type int_fast32_t = crate::binary::c_types::c_int;
pub type int_fast64_t = crate::binary::c_types::c_longlong;
pub type uint_fast8_t = crate::binary::c_types::c_uchar;
pub type uint_fast16_t = crate::binary::c_types::c_uint;
pub type uint_fast32_t = crate::binary::c_types::c_uint;
pub type uint_fast64_t = crate::binary::c_types::c_ulonglong;
pub type intmax_t = crate::binary::c_types::c_longlong;
pub type uintmax_t = crate::binary::c_types::c_ulonglong;
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: crate::binary::c_types::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = crate::binary::c_types::c_int;
pub type wint_t = crate::binary::c_types::c_ushort;
pub type wctype_t = crate::binary::c_types::c_ushort;
pub type __time32_t = crate::binary::c_types::c_long;
pub type __time64_t = crate::binary::c_types::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const crate::binary::c_types::c_ushort,
    pub _locale_mb_cur_max: crate::binary::c_types::c_int,
    pub _locale_lc_codepage: crate::binary::c_types::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: crate::binary::c_types::c_ulong,
    pub _Byte: crate::binary::c_types::c_ushort,
    pub _State: crate::binary::c_types::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
extern "C" {
    pub fn _errno() -> *mut crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: crate::binary::c_types::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut crate::binary::c_types::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
extern "C" {
    pub fn __doserrno() -> *mut crate::binary::c_types::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: crate::binary::c_types::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut crate::binary::c_types::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const crate::binary::c_types::c_void,
        _Val: crate::binary::c_types::c_int,
        _MaxCount: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const crate::binary::c_types::c_void,
        _Buf2: *const crate::binary::c_types::c_void,
        _Size: crate::binary::c_types::c_ulonglong,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut crate::binary::c_types::c_void,
        _Src: *const crate::binary::c_types::c_void,
        _Size: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut crate::binary::c_types::c_void,
        _Src: *const crate::binary::c_types::c_void,
        _Size: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut crate::binary::c_types::c_void,
        _Val: crate::binary::c_types::c_int,
        _Size: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const crate::binary::c_types::c_char,
        _Val: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const crate::binary::c_types::c_char,
        _Ch: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const crate::binary::c_types::c_char,
        _SubStr: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const crate::binary::c_types::c_ushort,
        _Ch: crate::binary::c_types::c_ushort,
    ) -> *mut crate::binary::c_types::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const crate::binary::c_types::c_void,
        _Buf2: *const crate::binary::c_types::c_void,
        _Size: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const crate::binary::c_types::c_void,
        _Buf2: *const crate::binary::c_types::c_void,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut crate::binary::c_types::c_void,
        _Src: *const crate::binary::c_types::c_void,
        _Val: crate::binary::c_types::c_int,
        _Size: size_t,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const crate::binary::c_types::c_void,
        _Buf2: *const crate::binary::c_types::c_void,
        _Size: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const crate::binary::c_types::c_ushort,
        _String2: *const crate::binary::c_types::c_ushort,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcslen(
        _String: *const crate::binary::c_types::c_ushort,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const crate::binary::c_types::c_ushort,
        _String2: *const crate::binary::c_types::c_ushort,
        _MaxCount: crate::binary::c_types::c_ulonglong,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: crate::binary::c_types::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorNumber: crate::binary::c_types::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: size_t,
        _Value: wchar_t,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: size_t, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut crate::binary::c_types::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const crate::binary::c_types::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut crate::binary::c_types::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const crate::binary::c_types::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut crate::binary::c_types::c_char,
        _SizeInBytes: size_t,
        _ErrorNumber: crate::binary::c_types::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut crate::binary::c_types::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const crate::binary::c_types::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut crate::binary::c_types::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const crate::binary::c_types::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut crate::binary::c_types::c_char,
        _Delimiter: *const crate::binary::c_types::c_char,
        _Context: *mut *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut crate::binary::c_types::c_void,
        _Src: *const crate::binary::c_types::c_void,
        _Val: crate::binary::c_types::c_int,
        _MaxCount: size_t,
    ) -> *mut crate::binary::c_types::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const crate::binary::c_types::c_char,
        _Str2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const crate::binary::c_types::c_char,
        _Control: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strdup(
        _Source: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strerror(
        _ErrorMessage: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut crate::binary::c_types::c_char,
        _SizeInBytes: size_t,
        _ErrorMessage: *const crate::binary::c_types::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(
        _ErrorMessage: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strlen(
        _Str: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut crate::binary::c_types::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr(
        _String: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut crate::binary::c_types::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut crate::binary::c_types::c_char,
        _Locale: _locale_t,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
        _Count: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const crate::binary::c_types::c_char,
        _Str2: *const crate::binary::c_types::c_char,
        _MaxCount: crate::binary::c_types::c_ulonglong,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const crate::binary::c_types::c_char, _Count: size_t) -> size_t;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
        _Count: crate::binary::c_types::c_ulonglong,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const crate::binary::c_types::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut crate::binary::c_types::c_char,
        _SizeInBytes: size_t,
        _Value: crate::binary::c_types::c_int,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut crate::binary::c_types::c_char,
        _Value: crate::binary::c_types::c_int,
        _Count: size_t,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const crate::binary::c_types::c_char,
        _Control: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strrev(
        _Str: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut crate::binary::c_types::c_char,
        _DestinationSize: size_t,
        _Value: crate::binary::c_types::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut crate::binary::c_types::c_char,
        _Value: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const crate::binary::c_types::c_char,
        _Control: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut crate::binary::c_types::c_char,
        _Delimiter: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut crate::binary::c_types::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strupr(
        _String: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut crate::binary::c_types::c_char,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut crate::binary::c_types::c_char,
        _Locale: _locale_t,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
        _MaxCount: crate::binary::c_types::c_ulonglong,
    ) -> crate::binary::c_types::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut crate::binary::c_types::c_char,
        _Source: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(
        _String: *const crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strlwr(
        _String: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const crate::binary::c_types::c_char,
        _String2: *const crate::binary::c_types::c_char,
        _MaxCount: size_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut crate::binary::c_types::c_char,
        _Value: crate::binary::c_types::c_int,
        _MaxCount: size_t,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strrev(
        _String: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut crate::binary::c_types::c_char,
        _Value: crate::binary::c_types::c_int,
    ) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn strupr(
        _String: *mut crate::binary::c_types::c_char,
    ) -> *mut crate::binary::c_types::c_char;
}
#[doc = " Private Types"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bl_ops_funcs {
    pub _version: crate::binary::c_types::c_int,
    pub _printf: ::core::option::Option<
        unsafe extern "C" fn(fmt: *const crate::binary::c_types::c_char, ...),
    >,
    pub _assert: ::core::option::Option<
        unsafe extern "C" fn(
            file: *const crate::binary::c_types::c_char,
            line: crate::binary::c_types::c_int,
            func: *const crate::binary::c_types::c_char,
            expr: *const crate::binary::c_types::c_char,
        ),
    >,
    pub _init: ::core::option::Option<unsafe extern "C" fn() -> crate::binary::c_types::c_int>,
    pub _enter_critical: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _exit_critical: ::core::option::Option<unsafe extern "C" fn(level: u32)>,
    pub _msleep: ::core::option::Option<
        unsafe extern "C" fn(ms: crate::binary::c_types::c_long) -> crate::binary::c_types::c_int,
    >,
    pub _sleep: ::core::option::Option<
        unsafe extern "C" fn(
            seconds: crate::binary::c_types::c_uint,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _event_group_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::binary::c_types::c_void>,
    pub _event_group_delete:
        ::core::option::Option<unsafe extern "C" fn(event: *mut crate::binary::c_types::c_void)>,
    pub _event_group_send: ::core::option::Option<
        unsafe extern "C" fn(event: *mut crate::binary::c_types::c_void, bits: u32) -> u32,
    >,
    pub _event_group_wait: ::core::option::Option<
        unsafe extern "C" fn(
            event: *mut crate::binary::c_types::c_void,
            bits_to_wait_for: u32,
            clear_on_exit: crate::binary::c_types::c_int,
            wait_for_all_bits: crate::binary::c_types::c_int,
            block_time_tick: u32,
        ) -> u32,
    >,
    pub _event_register: ::core::option::Option<
        unsafe extern "C" fn(
            type_: crate::binary::c_types::c_int,
            cb: *mut crate::binary::c_types::c_void,
            arg: *mut crate::binary::c_types::c_void,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _event_notify: ::core::option::Option<
        unsafe extern "C" fn(
            evt: crate::binary::c_types::c_int,
            val: crate::binary::c_types::c_int,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _task_create: ::core::option::Option<
        unsafe extern "C" fn(
            name: *const crate::binary::c_types::c_char,
            entry: *mut crate::binary::c_types::c_void,
            stack_depth: u32,
            param: *mut crate::binary::c_types::c_void,
            prio: u32,
            task_handle: *mut crate::binary::c_types::c_void,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _task_delete: ::core::option::Option<
        unsafe extern "C" fn(task_handle: *mut crate::binary::c_types::c_void),
    >,
    pub _task_get_current_task:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::binary::c_types::c_void>,
    pub _task_notify_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::binary::c_types::c_void>,
    pub _task_notify: ::core::option::Option<
        unsafe extern "C" fn(task_handle: *mut crate::binary::c_types::c_void),
    >,
    pub _task_wait: ::core::option::Option<
        unsafe extern "C" fn(task_handle: *mut crate::binary::c_types::c_void, tick: u32),
    >,
    pub _lock_gaint: ::core::option::Option<unsafe extern "C" fn()>,
    pub _unlock_gaint: ::core::option::Option<unsafe extern "C" fn()>,
    pub _irq_attach: ::core::option::Option<
        unsafe extern "C" fn(
            n: i32,
            f: *mut crate::binary::c_types::c_void,
            arg: *mut crate::binary::c_types::c_void,
        ),
    >,
    pub _irq_enable: ::core::option::Option<unsafe extern "C" fn(n: i32)>,
    pub _irq_disable: ::core::option::Option<unsafe extern "C" fn(n: i32)>,
    pub _workqueue_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::binary::c_types::c_void>,
    pub _workqueue_submit_hp: ::core::option::Option<
        unsafe extern "C" fn(
            work: *mut crate::binary::c_types::c_void,
            woker: *mut crate::binary::c_types::c_void,
            argv: *mut crate::binary::c_types::c_void,
            tick: crate::binary::c_types::c_long,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _workqueue_submit_lp: ::core::option::Option<
        unsafe extern "C" fn(
            work: *mut crate::binary::c_types::c_void,
            woker: *mut crate::binary::c_types::c_void,
            argv: *mut crate::binary::c_types::c_void,
            tick: crate::binary::c_types::c_long,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _timer_create: ::core::option::Option<
        unsafe extern "C" fn(
            func: *mut crate::binary::c_types::c_void,
            argv: *mut crate::binary::c_types::c_void,
        ) -> *mut crate::binary::c_types::c_void,
    >,
    pub _timer_delete: ::core::option::Option<
        unsafe extern "C" fn(
            timerid: *mut crate::binary::c_types::c_void,
            tick: u32,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _timer_start_once: ::core::option::Option<
        unsafe extern "C" fn(
            timerid: *mut crate::binary::c_types::c_void,
            t_sec: crate::binary::c_types::c_long,
            t_nsec: crate::binary::c_types::c_long,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _timer_start_periodic: ::core::option::Option<
        unsafe extern "C" fn(
            timerid: *mut crate::binary::c_types::c_void,
            t_sec: crate::binary::c_types::c_long,
            t_nsec: crate::binary::c_types::c_long,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _sem_create: ::core::option::Option<
        unsafe extern "C" fn(init: u32) -> *mut crate::binary::c_types::c_void,
    >,
    pub _sem_delete:
        ::core::option::Option<unsafe extern "C" fn(semphr: *mut crate::binary::c_types::c_void)>,
    pub _sem_take: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::binary::c_types::c_void, tick: u32) -> i32,
    >,
    pub _sem_give: ::core::option::Option<
        unsafe extern "C" fn(semphr: *mut crate::binary::c_types::c_void) -> i32,
    >,
    pub _mutex_create:
        ::core::option::Option<unsafe extern "C" fn() -> *mut crate::binary::c_types::c_void>,
    pub _mutex_delete:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut crate::binary::c_types::c_void)>,
    pub _mutex_lock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut crate::binary::c_types::c_void) -> i32,
    >,
    pub _mutex_unlock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut crate::binary::c_types::c_void) -> i32,
    >,
    pub _queue_create: ::core::option::Option<
        unsafe extern "C" fn(queue_len: u32, item_size: u32) -> *mut crate::binary::c_types::c_void,
    >,
    pub _queue_delete:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut crate::binary::c_types::c_void)>,
    pub _queue_send_wait: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::binary::c_types::c_void,
            item: *mut crate::binary::c_types::c_void,
            len: u32,
            ticks: u32,
            prio: crate::binary::c_types::c_int,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _queue_send: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::binary::c_types::c_void,
            item: *mut crate::binary::c_types::c_void,
            len: u32,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _queue_recv: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut crate::binary::c_types::c_void,
            item: *mut crate::binary::c_types::c_void,
            len: u32,
            tick: u32,
        ) -> crate::binary::c_types::c_int,
    >,
    pub _malloc: ::core::option::Option<
        unsafe extern "C" fn(
            size: crate::binary::c_types::c_uint,
        ) -> *mut crate::binary::c_types::c_void,
    >,
    pub _free: ::core::option::Option<unsafe extern "C" fn(p: *mut crate::binary::c_types::c_void)>,
    pub _zalloc: ::core::option::Option<
        unsafe extern "C" fn(
            size: crate::binary::c_types::c_uint,
        ) -> *mut crate::binary::c_types::c_void,
    >,
    pub _get_time_ms: ::core::option::Option<unsafe extern "C" fn() -> u64>,
    pub _get_tick: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    pub _log_write: ::core::option::Option<
        unsafe extern "C" fn(
            level: u32,
            tag: *const crate::binary::c_types::c_char,
            file: *const crate::binary::c_types::c_char,
            line: crate::binary::c_types::c_int,
            format: *const crate::binary::c_types::c_char,
            ...
        ),
    >,
}
pub type bl_ops_funcs_t = bl_ops_funcs;
extern "C" {
    pub static mut g_bl_ops_funcs: bl_ops_funcs_t;
}
pub const _bl_os_log_leve_LOG_LEVEL_ALL: _bl_os_log_leve = 0;
pub const _bl_os_log_leve_LOG_LEVEL_DEBUG: _bl_os_log_leve = 1;
pub const _bl_os_log_leve_LOG_LEVEL_INFO: _bl_os_log_leve = 2;
pub const _bl_os_log_leve_LOG_LEVEL_WARN: _bl_os_log_leve = 3;
pub const _bl_os_log_leve_LOG_LEVEL_ERROR: _bl_os_log_leve = 4;
pub const _bl_os_log_leve_LOG_LEVEL_ASSERT: _bl_os_log_leve = 5;
pub const _bl_os_log_leve_LOG_LEVEL_NEVER: _bl_os_log_leve = 6;
#[doc = " Definition"]
pub type _bl_os_log_leve = crate::binary::c_types::c_int;
pub use self::_bl_os_log_leve as bl_os_log_level_t;
pub const ap_info_type_AP_INFO_TYPE_SUGGEST: ap_info_type = 0;
pub const ap_info_type_AP_INFO_TYPE_PRESIST: ap_info_type = 1;
pub type ap_info_type = crate::binary::c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_info {
    pub type_: ap_info_type,
    pub time_to_live: crate::binary::c_types::c_int,
    pub bssid: *mut u8,
    pub band: u8,
    pub freq: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_connect_adv {
    pub psk: *mut crate::binary::c_types::c_char,
    pub ap_info: ap_info,
}
pub type ap_connect_adv_t = ap_connect_adv;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ap_item {
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub ssid_len: u32,
    pub bssid: [u8; 6usize],
    pub channel: u8,
    pub auth: u8,
    pub rssi: i8,
}
pub type wifi_mgmr_ap_item_t = wifi_mgmr_ap_item;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_sta_connect_ind_stat_info {
    pub status_code: u16,
    pub type_ind: u8,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub passphr: [crate::binary::c_types::c_char; 65usize],
    pub psk: [crate::binary::c_types::c_char; 64usize],
    pub bssid: [u8; 6usize],
    pub chan_freq: u16,
    pub chan_band: u8,
}
pub type wifi_mgmr_sta_connect_ind_stat_info_t = wifi_mgmr_sta_connect_ind_stat_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_basic_info {
    pub sta_idx: u8,
    pub is_used: u8,
    pub sta_mac: [u8; 6usize],
    pub tsfhi: u32,
    pub tsflo: u32,
    pub rssi: crate::binary::c_types::c_int,
    pub data_rate: u8,
}
pub type wifi_sta_basic_info_t = wifi_sta_basic_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_ps_conf {
    #[doc = " num of beacons"]
    pub listen_interval: crate::binary::c_types::c_int,
    #[doc = "wifi active ms."]
    pub wifi_active_period: u16,
}
pub type wifi_sta_ps_conf_t = wifi_sta_ps_conf;
pub type wifi_interface_t = *mut crate::binary::c_types::c_void;
pub type sniffer_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        env: *mut crate::binary::c_types::c_void,
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ),
>;
pub type scan_item_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        env: *mut wifi_mgmr_ap_item_t,
        param1: *mut u32,
        item: *mut wifi_mgmr_ap_item_t,
    ),
>;
pub type scan_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::binary::c_types::c_void,
        param: *mut crate::binary::c_types::c_void,
    ),
>;
#[doc = " Power-save off"]
pub const PS_MODE_OFF: crate::binary::c_types::c_int = 0;
#[doc = " Power-save on - Normal mode"]
pub const PS_MODE_ON: crate::binary::c_types::c_int = 1;
#[doc = " Power-save on - Dynamic mode"]
pub const PS_MODE_ON_DYN: crate::binary::c_types::c_int = 2;
#[doc = " Power Save mode setting"]
pub type _bindgen_ty_1 = crate::binary::c_types::c_int;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_UNKNOWN: WIFI_STATE_ENUM_LIST = 0;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_IDLE: WIFI_STATE_ENUM_LIST = 1;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTING: WIFI_STATE_ENUM_LIST = 2;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTED_IP_GETTING: WIFI_STATE_ENUM_LIST = 3;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTED_IP_GOT: WIFI_STATE_ENUM_LIST = 4;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_DISCONNECT: WIFI_STATE_ENUM_LIST = 5;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_IDLE: WIFI_STATE_ENUM_LIST = 17;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTING: WIFI_STATE_ENUM_LIST = 18;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING: WIFI_STATE_ENUM_LIST = 19;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTED_IP_GOT: WIFI_STATE_ENUM_LIST = 20;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_DISCONNECT: WIFI_STATE_ENUM_LIST = 21;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_IFDOWN: WIFI_STATE_ENUM_LIST = 6;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_SNIFFER: WIFI_STATE_ENUM_LIST = 7;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_PSK_ERROR: WIFI_STATE_ENUM_LIST = 8;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_NO_AP_FOUND: WIFI_STATE_ENUM_LIST = 9;
pub type WIFI_STATE_ENUM_LIST = crate::binary::c_types::c_int;
pub const WIFI_SCAN_DONE_EVENT_TYPE_WIFI_SCAN_DONE_EVENT_OK: WIFI_SCAN_DONE_EVENT_TYPE = 0;
pub const WIFI_SCAN_DONE_EVENT_TYPE_WIFI_SCAN_DONE_EVENT_BUSY: WIFI_SCAN_DONE_EVENT_TYPE = 1;
pub type WIFI_SCAN_DONE_EVENT_TYPE = crate::binary::c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_conf {
    pub country_code: [crate::binary::c_types::c_char; 3usize],
    pub channel_nums: crate::binary::c_types::c_int,
}
pub type wifi_conf_t = wifi_conf;
extern "C" {
    pub fn wifi_mgmr_psk_cal(
        password: *mut crate::binary::c_types::c_char,
        ssid: *mut crate::binary::c_types::c_char,
        ssid_len: crate::binary::c_types::c_int,
        output: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_drv_init(conf: *mut wifi_conf_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_init() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_start();
}
extern "C" {
    pub fn wifi_mgmr_start_background(conf: *mut wifi_conf_t);
}
extern "C" {
    pub fn wifi_mgmr_get_wifi_channel_conf(wifi_chan_conf: *mut wifi_conf_t);
}
extern "C" {
    pub fn wifi_mgmr_sta_enable(opaque: *mut crate::binary::c_types::c_void) -> wifi_interface_t;
}
extern "C" {
    pub fn wifi_mgmr_sta_disable(interface: *mut wifi_interface_t)
        -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_mac_set(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_mac_get(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_get(
        ip: *mut u32,
        gw: *mut u32,
        mask: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_set(
        ip: u32,
        mask: u32,
        gw: u32,
        dns1: u32,
        dns2: u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_dns_get(dns1: *mut u32, dns2: *mut u32) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_unset() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_connect_ext(
        wifi_interface: *mut wifi_interface_t,
        ssid: *mut crate::binary::c_types::c_char,
        passphr: *mut crate::binary::c_types::c_char,
        conn_adv_param: *const ap_connect_adv_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_connect(
        wifi_interface: *mut wifi_interface_t,
        ssid: *mut crate::binary::c_types::c_char,
        psk: *mut crate::binary::c_types::c_char,
        pmk: *mut crate::binary::c_types::c_char,
        mac: *mut u8,
        band: u8,
        freq: u16,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ps_enter(ps_level: u32) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ps_exit() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_autoconnect_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_autoconnect_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ssid_set(ssid: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn wifi_mgmr_sta_passphr_set(passphr: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn wifi_mgmr_sta_psk_set(psk: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn wifi_mgmr_sta_connect_ind_stat_get(
        wifi_mgmr_ind_stat: *mut wifi_mgmr_sta_connect_ind_stat_info_t,
    );
}
extern "C" {
    pub fn wifi_mgmr_ap_enable(opaque: *mut crate::binary::c_types::c_void) -> wifi_interface_t;
}
extern "C" {
    pub fn wifi_mgmr_ap_mac_set(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_mac_get(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_ip_get(
        ip: *mut u32,
        gw: *mut u32,
        mask: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_stop(interface: *mut wifi_interface_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_start(
        interface: *mut wifi_interface_t,
        ssid: *mut crate::binary::c_types::c_char,
        hidden_ssid: crate::binary::c_types::c_int,
        passwd: *mut crate::binary::c_types::c_char,
        channel: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_cnt_get(sta_cnt: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_info_get(
        sta_info: *mut wifi_sta_basic_info,
        idx: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_delete(sta_idx: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_set_gateway(
        gateway: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_rate_config(config: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_conf_max_sta(max_sta_supported: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_register(
        env: *mut crate::binary::c_types::c_void,
        cb: sniffer_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_unregister(
        env: *mut crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_state_get(
        state: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_get(
        s_code: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_rssi_get(
        rssi: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_channel_get(
        channel: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_channel_set(
        channel: crate::binary::c_types::c_int,
        use_40Mhz: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_all_ap_scan(
        ap_ary: *mut *mut wifi_mgmr_ap_item_t,
        num: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_filter_hidden_ssid(
        filter: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan(
        data: *mut crate::binary::c_types::c_void,
        cb: scan_complete_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_fixed_channels(
        data: *mut crate::binary::c_types::c_void,
        cb: scan_complete_cb_t,
        channels: *mut u16,
        channel_num: u16,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_adv(
        data: *mut crate::binary::c_types::c_void,
        cb: scan_complete_cb_t,
        channels: *mut u16,
        channel_num: u16,
        ssid: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cfg_req(
        ops: u32,
        task: u32,
        element: u32,
        type_: u32,
        length: u32,
        buf: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_complete_callback() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cli_scanlist() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cli_init() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_ap(
        ssid: *mut crate::binary::c_types::c_char,
        item: *mut wifi_mgmr_ap_item_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_ap_all(
        env: *mut wifi_mgmr_ap_item_t,
        param1: *mut u32,
        cb: scan_item_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_raw_80211_send(
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_set_country_code(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ext_dump_needed() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_reset();
}
extern "C" {
    pub fn wifi_mgmr_status_code_str(status_code: u16) -> *const crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wifi_mgmr_beacon_interval_set(beacon_int: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_conn_result_get(status_code: *mut u16, reason_code: *mut u16);
}
extern "C" {
    pub fn wifi_mgmr_set_wifi_active_time(ms: u32) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_set_listen_interval(itv: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_pm_ops_register() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_fw_affair_ops() -> crate::binary::c_types::c_int;
}
#[doc = " \\brief Event"]
#[doc = ""]
#[doc = " Events trigger transitions from a state to another. Event types are defined"]
#[doc = " by the user. Any event may optionally contain a \\ref #event::data"]
#[doc = " \"payload\"."]
#[doc = ""]
#[doc = " \\sa state"]
#[doc = " \\sa transition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event {
    #[doc = " \\brief Type of event. Defined by user."]
    pub type_: crate::binary::c_types::c_int,
    #[doc = " \\brief Event payload."]
    #[doc = ""]
    #[doc = " How this is used is entirely up to the user. This data"]
    #[doc = " is always passed together with #type in order to make it possible to"]
    #[doc = " always cast the data correctly."]
    pub data: *mut crate::binary::c_types::c_void,
}
#[doc = " \\brief Transition between a state and another state"]
#[doc = ""]
#[doc = " All states that are not final must have at least one transition. The"]
#[doc = " transition may be guarded or not. Transitions are triggered by events. If"]
#[doc = " a state has more than one transition with the same type of event (and the"]
#[doc = " same condition), the first transition in the array will be run. An"]
#[doc = " unconditional transition placed last in the transition array of a state can"]
#[doc = " act as a \"catch-all\". A transition may optionally run an #action, which"]
#[doc = " will have the triggering event passed to it as an argument, along with the"]
#[doc = " current and new states' \\ref state::data \"data\"."]
#[doc = ""]
#[doc = " It is perfectly valid for a transition to return to the state it belongs"]
#[doc = " to. Such a transition will not call the state's \\ref state::entryAction"]
#[doc = " \"entry action\" or \\ref state::exitAction \"exit action\". If there are no"]
#[doc = " transitions for the current event, the state's parent will be handed the"]
#[doc = " event."]
#[doc = ""]
#[doc = " ### Examples ###"]
#[doc = " - An ungarded transition to a state with no action performed:"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_timeout,"]
#[doc = "    .condition = NULL,"]
#[doc = "    .guard = NULL,"]
#[doc = "    .action = NULL,"]
#[doc = "    .nextState = &mainMenuState,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " - A guarded transition executing an action"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_keyboard,"]
#[doc = "    .condition = NULL,"]
#[doc = "    .guard = &ensureNumericInput,"]
#[doc = "    .action = &addToBuffer,"]
#[doc = "    .nextState = &awaitingInputState,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " - A guarded transition using a condition"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_mouse,"]
#[doc = "    .condition = boxLimits,"]
#[doc = "    .guard = &coordinatesWithinLimits,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " By using \\ref #condition \"conditions\" a more general guard function can be"]
#[doc = " used, operating on the supplied argument #condition. In this example,"]
#[doc = " `coordinatesWithinLimits` checks whether the coordinates in the mouse event"]
#[doc = " are within the limits of the \"box\"."]
#[doc = ""]
#[doc = " \\sa event"]
#[doc = " \\sa state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct transition {
    #[doc = " \\brief The event that will trigger this transition."]
    pub eventType: crate::binary::c_types::c_int,
    #[doc = " \\brief Condition that event must fulfil"]
    #[doc = ""]
    #[doc = " This variable will be passed to the #guard (if #guard is non-NULL) and"]
    #[doc = " may be used as a condition that the incoming event's data must fulfil in"]
    #[doc = " order for the transition to be performed. By using this variable, the"]
    #[doc = " number of #guard functions can be minimised by making them more general."]
    pub condition: *mut crate::binary::c_types::c_void,
    #[doc = " \\brief Check if data passed with event fulfils a condition"]
    #[doc = ""]
    #[doc = " A transition may be conditional. If so, this function, if non-NULL, will"]
    #[doc = " be called. Its first argument will be supplied with #condition, which"]
    #[doc = " can be compared against the \\ref event::data \"payload\" in the #event."]
    #[doc = " The user may choose to use this argument or not. Only if the result is"]
    #[doc = " true, the transition will take place."]
    #[doc = ""]
    #[doc = " \\param condition event (data) to compare the incoming event against."]
    #[doc = " \\param event the event passed to the state machine."]
    #[doc = ""]
    #[doc = " \\returns true if the event's data fulfils the condition, otherwise false."]
    pub guard: ::core::option::Option<
        unsafe extern "C" fn(
            condition: *mut crate::binary::c_types::c_void,
            event: *mut event,
        ) -> bool,
    >,
    #[doc = " \\brief Function containing tasks to be performed during the transition"]
    #[doc = ""]
    #[doc = " The transition may optionally do some work in this function before"]
    #[doc = " entering the next state. May be NULL."]
    #[doc = ""]
    #[doc = " \\param currentStateData the leaving state's \\ref state::data \"data\""]
    #[doc = " \\param event the event passed to the state machine."]
    #[doc = " \\param newStateData the new state's (the \\ref state::entryState"]
    #[doc = " \"entryState\" of any (chain of) parent states, not the parent state"]
    #[doc = " itself) \\ref state::data \"data\""]
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            currentStateData: *mut crate::binary::c_types::c_void,
            event: *mut event,
            newStateData: *mut crate::binary::c_types::c_void,
        ),
    >,
    #[doc = " \\brief The next state"]
    #[doc = ""]
    #[doc = " This must point to the next state that will be entered. It cannot be"]
    #[doc = " NULL. If it is, the state machine will detect it and enter the \\ref"]
    #[doc = " stateMachine::errorState \"error state\"."]
    pub nextState: *const state,
}
#[doc = " \\brief State"]
#[doc = ""]
#[doc = " The current state in a state machine moves to a new state when one of the"]
#[doc = " #transitions in the current state triggers on an event. An optional \\ref"]
#[doc = " #exitAction \"exit action\" is called when the state is left, and an \\ref"]
#[doc = " #entryAction \"entry action\" is called when the state machine enters a new"]
#[doc = " state. If a state returns to itself, neither #exitAction nor #entryAction"]
#[doc = " will be called. An optional \\ref transition::action \"transition action\" is"]
#[doc = " called in either case."]
#[doc = ""]
#[doc = " States may be organised in a hierarchy by setting \\ref #parentState"]
#[doc = " \"parent states\". When a group/parent state is entered, the state machine is"]
#[doc = " redirected to the group state's \\ref #entryState \"entry state\" (if"]
#[doc = " non-NULL). If an event does not trigger a transition in a state and if the"]
#[doc = " state has a parent state, the event will be passed to the parent state."]
#[doc = " This behaviour is repeated for all parents. Thus all children of a state"]
#[doc = " have a set of common #transitions. A parent state's #entryAction will not"]
#[doc = " be called if an event is passed on to a child state."]
#[doc = ""]
#[doc = " The following lists the different types of states that may be created, and"]
#[doc = " how to create them:"]
#[doc = ""]
#[doc = " ### Normal state ###"]
#[doc = " ~~~{.c}"]
#[doc = " struct state normalState = {"]
#[doc = "    .parentState = &groupState,"]
#[doc = "    .entryState = NULL,"]
#[doc = "    .transition = (struct transition[]){"]
#[doc = "       { Event_keyboard, (void *)(intptr_t)'\\n', &compareKeyboardChar,"]
#[doc = "          NULL, &msgReceivedState },"]
#[doc = "    },"]
#[doc = "    .numTransitions = 1,"]
#[doc = "    .data = normalStateData,"]
#[doc = "    .entryAction = &doSomething,"]
#[doc = "    .exitAction = &cleanUp,"]
#[doc = " };"]
#[doc = " ~~~"]
#[doc = " In this example, `normalState` is a child of `groupState`, but the"]
#[doc = " #parentState value may also be NULL to indicate that it is not a child of"]
#[doc = " any group state."]
#[doc = ""]
#[doc = " ### Group/parent state ###"]
#[doc = " A state becomes a group/parent state when it is linked to by child states"]
#[doc = " by using #parentState. No members in the group state need to be set in a"]
#[doc = " particular way. A parent state may also have a parent."]
#[doc = " ~~~{.c}"]
#[doc = " struct state groupState = {"]
#[doc = "    .entryState = &normalState,"]
#[doc = "    .entryAction = NULL,"]
#[doc = " ~~~"]
#[doc = " If there are any transitions in the state machine that lead to a group"]
#[doc = " state, it makes sense to define an entry state in the group. This can be"]
#[doc = " done by using #entryState, but it is not mandatory. If the #entryState"]
#[doc = " state has children, the chain of children will be traversed until a child"]
#[doc = " with its #entryState set to NULL is found."]
#[doc = ""]
#[doc = " \\note If #entryState is defined for a group state, the group state's"]
#[doc = " #entryAction will not be called (the state pointed to by #entryState (after"]
#[doc = " following the chain of children), however, will have its #entryAction"]
#[doc = " called)."]
#[doc = ""]
#[doc = " \\warning The state machine cannot detect cycles in parent chains and"]
#[doc = " children chains. If such cycles are present, stateM_handleEvent() will"]
#[doc = " never finish due to never-ending loops."]
#[doc = ""]
#[doc = " ### Final state ###"]
#[doc = " A final state is a state that terminates the state machine. A state is"]
#[doc = " considered as a final state if its #numTransitions is 0:"]
#[doc = " ~~~{.c}"]
#[doc = " struct state finalState = {"]
#[doc = "    .transitions = NULL,"]
#[doc = "    .numTransitions = 0,"]
#[doc = " ~~~"]
#[doc = " The error state used by the state machine to indicate errors should be a"]
#[doc = " final state. Any calls to stateM_handleEvent() when the current state is a"]
#[doc = " final state will return #stateM_noStateChange."]
#[doc = ""]
#[doc = " \\sa event"]
#[doc = " \\sa transition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct state {
    #[doc = " \\brief If the state has a parent state, this pointer must be non-NULL."]
    pub parentState: *const state,
    #[doc = " \\brief If this state is a parent state, this pointer may point to a"]
    #[doc = " child state that serves as an entry point."]
    pub entryState: *const state,
    #[doc = " \\brief An array of transitions for the state."]
    pub transitions: *mut transition,
    #[doc = " \\brief Number of transitions in the #transitions array."]
    pub numTransitions: size_t,
    #[doc = " \\brief Data that will be available for the state in its #entryAction and"]
    #[doc = " #exitAction, and in any \\ref transition::action \"transition action\""]
    pub data: *mut crate::binary::c_types::c_void,
    #[doc = " \\brief This function is called whenever the state is being entered. May"]
    #[doc = " be NULL."]
    #[doc = ""]
    #[doc = " \\note If a state returns to itself through a transition (either directly"]
    #[doc = " or through a parent/group sate), its #entryAction will not be called."]
    #[doc = ""]
    #[doc = " \\note A group/parent state with its #entryState defined will not have"]
    #[doc = " its #entryAction called."]
    #[doc = ""]
    #[doc = " \\param stateData the state's #data will be passed."]
    #[doc = " \\param event the event that triggered the transition will be passed."]
    pub entryAction: ::core::option::Option<
        unsafe extern "C" fn(stateData: *mut crate::binary::c_types::c_void, event: *mut event),
    >,
    #[doc = " \\brief This function is called whenever the state is being left. May be"]
    #[doc = " NULL."]
    #[doc = ""]
    #[doc = " \\note If a state returns to itself through a transition (either directly"]
    #[doc = " or through a parent/group sate), its #exitAction will not be called."]
    #[doc = ""]
    #[doc = " \\param stateData the state's #data will be passed."]
    #[doc = " \\param event the event that triggered a transition will be passed."]
    pub exitAction: ::core::option::Option<
        unsafe extern "C" fn(stateData: *mut crate::binary::c_types::c_void, event: *mut event),
    >,
}
#[doc = " \\brief State machine"]
#[doc = ""]
#[doc = " There is no need to manipulate the members directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stateMachine {
    #[doc = " \\brief Pointer to the current state"]
    pub currentState: *const state,
    #[doc = " \\brief Pointer to previous state"]
    #[doc = ""]
    #[doc = " The previous state is stored for convenience in case the user needs to"]
    #[doc = " keep track of previous states."]
    pub previousState: *const state,
    #[doc = " \\brief Pointer to a state that will be entered whenever an error occurs"]
    #[doc = " in the state machine."]
    #[doc = ""]
    #[doc = " See #stateM_errorStateReached for when the state machine enters the"]
    #[doc = " error state."]
    pub errorState: *const state,
}
extern "C" {
    #[doc = " \\brief Initialise the state machine"]
    #[doc = ""]
    #[doc = " This function initialises the supplied stateMachine and sets the current"]
    #[doc = " state to \\pn{initialState}. No actions are performed until"]
    #[doc = " stateM_handleEvent() is called. It is safe to call this function numerous"]
    #[doc = " times, for instance in order to reset/restart the state machine if a final"]
    #[doc = " state has been reached."]
    #[doc = ""]
    #[doc = " \\note The \\ref #state::entryAction \"entry action\" for \\pn{initialState}"]
    #[doc = " will not be called."]
    #[doc = ""]
    #[doc = " \\note If \\pn{initialState} is a parent state with its \\ref"]
    #[doc = " state::entryState \"entryState\" defined, it will not be entered. The user"]
    #[doc = " must explicitly set the initial state."]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to initialise."]
    #[doc = " \\param initialState the initial state of the state machine."]
    #[doc = " \\param errorState pointer to a state that acts a final state and notifies"]
    #[doc = " the system/user that an error has occurred."]
    pub fn stateM_init(
        stateMachine: *mut stateMachine,
        initialState: *const state,
        errorState: *const state,
    );
}
#[doc = " \\brief Erroneous arguments were passed"]
pub const stateM_handleEventRetVals_stateM_errArg: stateM_handleEventRetVals = -2;
#[doc = " \\brief The error state was reached"]
#[doc = ""]
#[doc = " This value is returned either when the state machine enters the error"]
#[doc = " state itself as a result of an error, or when the error state is the"]
#[doc = " next state as a result of a successful transition."]
#[doc = ""]
#[doc = " The state machine enters the state machine if any of the following"]
#[doc = " happens:"]
#[doc = " - The current state is NULL"]
#[doc = " - A transition for the current event did not define the next state"]
pub const stateM_handleEventRetVals_stateM_errorStateReached: stateM_handleEventRetVals = -1;
#[doc = " \\brief The current state changed into a non-final state"]
pub const stateM_handleEventRetVals_stateM_stateChanged: stateM_handleEventRetVals = 0;
#[doc = " \\brief The state changed back to itself"]
#[doc = ""]
#[doc = " The state can return to itself either directly or indirectly. An"]
#[doc = " indirect path may inlude a transition from a parent state and the use of"]
#[doc = " \\ref state::entryState \"entryStates\"."]
pub const stateM_handleEventRetVals_stateM_stateLoopSelf: stateM_handleEventRetVals = 1;
#[doc = " \\brief The current state did not change on the given event"]
#[doc = ""]
#[doc = " If any event passed to the state machine should result in a state"]
#[doc = " change, this return value should be considered as an error."]
pub const stateM_handleEventRetVals_stateM_noStateChange: stateM_handleEventRetVals = 2;
#[doc = " \\brief A final state (any but the error state) was reached"]
pub const stateM_handleEventRetVals_stateM_finalStateReached: stateM_handleEventRetVals = 3;
#[doc = " \\brief stateM_handleEvent() return values"]
pub type stateM_handleEventRetVals = crate::binary::c_types::c_int;
extern "C" {
    #[doc = " \\brief Pass an event to the state machine"]
    #[doc = ""]
    #[doc = " The event will be passed to the current state, and possibly to the current"]
    #[doc = " state's parent states (if any). If the event triggers a transition, a new"]
    #[doc = " state will be entered. If the transition has an \\ref transition::action"]
    #[doc = " \"action\" defined, it will be called. If the transition is to a state other"]
    #[doc = " than the current state, the current state's \\ref state::exitAction"]
    #[doc = " \"exit action\" is called (if defined). Likewise, if the state is a new"]
    #[doc = " state, the new state's \\ref state::entryAction \"entry action\" is called (if"]
    #[doc = " defined)."]
    #[doc = ""]
    #[doc = " The returned value is negative if an error occurs."]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to pass an event to."]
    #[doc = " \\param event the event to be handled."]
    #[doc = ""]
    #[doc = " \\return #stateM_handleEventRetVals"]
    pub fn stateM_handleEvent(
        stateMachine: *mut stateMachine,
        event: *mut event,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current state"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to get the current state from."]
    #[doc = ""]
    #[doc = " \\retval a pointer to the current state."]
    #[doc = " \\retval NULL if \\pn{stateMachine} is NULL."]
    pub fn stateM_currentState(stateMachine: *mut stateMachine) -> *const state;
}
extern "C" {
    #[doc = " \\brief Get the previous state"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to get the previous state from."]
    #[doc = ""]
    #[doc = " \\retval the previous state."]
    #[doc = " \\retval NULL if \\pn{stateMachine} is NULL."]
    #[doc = " \\retval NULL if there has not yet been any transitions."]
    pub fn stateM_previousState(stateMachine: *mut stateMachine) -> *const state;
}
extern "C" {
    #[doc = " \\brief Check if the state machine has stopped"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to test."]
    #[doc = ""]
    #[doc = " \\retval true if the state machine has reached a final state."]
    #[doc = " \\retval false if \\pn{stateMachine} is NULL or if the current state is not a"]
    #[doc = " final state."]
    pub fn stateM_stopped(stateMachine: *mut stateMachine) -> bool;
}
pub const EVENT_TYPE_EVENT_TYPE_FW: EVENT_TYPE = 0;
pub const EVENT_TYPE_EVENT_TYPE_APP: EVENT_TYPE = 1;
pub const EVENT_TYPE_EVENT_TYPE_GLB: EVENT_TYPE = 2;
#[doc = " @file wifi_mgmr.h"]
#[doc = " Copyright (C) Bouffalo Lab 2016-2018"]
#[doc = ""]
#[doc = ""]
pub type EVENT_TYPE = crate::binary::c_types::c_int;
pub const _WIFI_EVENT_CODE_WIFI_ON_INIT_DONE: _WIFI_EVENT = 1;
pub const _WIFI_EVENT_CODE_WIFI_ON_MGMR_DONE: _WIFI_EVENT = 2;
pub const _WIFI_EVENT_CODE_WIFI_CMD_RECONNECT: _WIFI_EVENT = 3;
pub const _WIFI_EVENT_CODE_WIFI_ON_CONNECTED: _WIFI_EVENT = 4;
pub const _WIFI_EVENT_CODE_WIFI_ON_DISCONNECT: _WIFI_EVENT = 5;
pub const _WIFI_EVENT_CODE_WIFI_ON_PRE_GOT_IP: _WIFI_EVENT = 6;
pub const _WIFI_EVENT_CODE_WIFI_ON_GOT_IP: _WIFI_EVENT = 7;
pub const _WIFI_EVENT_CODE_WIFI_ON_CONNECTING: _WIFI_EVENT = 8;
pub const _WIFI_EVENT_CODE_WIFI_ON_SCAN_DONE: _WIFI_EVENT = 9;
pub const _WIFI_EVENT_CODE_WIFI_ON_SCAN_DONE_ONJOIN: _WIFI_EVENT = 10;
pub const _WIFI_EVENT_CODE_WIFI_ON_AP_STARTED: _WIFI_EVENT = 11;
pub const _WIFI_EVENT_CODE_WIFI_ON_AP_STOPPED: _WIFI_EVENT = 12;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_SSID: _WIFI_EVENT = 13;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_BSSID: _WIFI_EVENT = 14;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_PASSWD: _WIFI_EVENT = 15;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_CONNECT: _WIFI_EVENT = 16;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_DISCONNECT: _WIFI_EVENT = 17;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_SCAN_START: _WIFI_EVENT = 18;
pub const _WIFI_EVENT_CODE_WIFI_ON_PROV_STATE_GET: _WIFI_EVENT = 19;
pub const _WIFI_EVENT_CODE_WIFI_ON_MGMR_DENOISE: _WIFI_EVENT = 20;
pub const _WIFI_EVENT_CODE_WIFI_ON_AP_STA_ADD: _WIFI_EVENT = 21;
pub const _WIFI_EVENT_CODE_WIFI_ON_AP_STA_DEL: _WIFI_EVENT = 22;
pub const _WIFI_EVENT_CODE_WIFI_ON_EMERGENCY_MAC: _WIFI_EVENT = 23;
pub type _WIFI_EVENT = crate::binary::c_types::c_int;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_IDLE: WIFI_MGMR_EVENT = 0;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONNECT: WIFI_MGMR_EVENT = 1;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_SNIFFER: WIFI_MGMR_EVENT = 2;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONNECTED: WIFI_MGMR_EVENT = 3;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_IP_GOT: WIFI_MGMR_EVENT = 4;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_DISCONNECT: WIFI_MGMR_EVENT = 5;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RECONNECT: WIFI_MGMR_EVENT = 6;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_PHY_UP: WIFI_MGMR_EVENT = 7;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_AP_START: WIFI_MGMR_EVENT = 8;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_AP_STOP: WIFI_MGMR_EVENT = 9;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONF_MAX_STA: WIFI_MGMR_EVENT = 10;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RC_CONFIG: WIFI_MGMR_EVENT = 11;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_DENOISE: WIFI_MGMR_EVENT = 12;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RELOAD_TSEN: WIFI_MGMR_EVENT = 13;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_MAXAPP_MINIFW: WIFI_MGMR_EVENT = 14;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_DISCONNECT: WIFI_MGMR_EVENT = 15;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_POWERSAVING: WIFI_MGMR_EVENT = 16;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_CHANNEL_SET: WIFI_MGMR_EVENT = 17;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_SCAN: WIFI_MGMR_EVENT = 18;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_IND_DISCONNECT: WIFI_MGMR_EVENT = 19;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_IND_CONNECTED: WIFI_MGMR_EVENT = 20;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_DATA_RAW_SEND: WIFI_MGMR_EVENT = 21;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_CFG_REQ: WIFI_MGMR_EVENT = 22;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_MAXFW_MINI_GLOBAL: WIFI_MGMR_EVENT = 23;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON: WIFI_MGMR_EVENT = 24;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_SCAN_IND_PROBE_RESP: WIFI_MGMR_EVENT = 25;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_AP_IND_STA_NEW: WIFI_MGMR_EVENT = 26;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_AP_IND_STA_DEL: WIFI_MGMR_EVENT = 27;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT: WIFI_MGMR_EVENT = 28;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT: WIFI_MGMR_EVENT = 29;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_IP_UPDATE: WIFI_MGMR_EVENT = 30;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_MGMR_WAKEUP: WIFI_MGMR_EVENT = 31;
pub type WIFI_MGMR_EVENT = crate::binary::c_types::c_int;
pub use self::WIFI_MGMR_EVENT as WIFI_MGMR_EVENT_T;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_IDLE:
    WIFI_MGMR_CONNECTION_STATUS = 0;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTING:
    WIFI_MGMR_CONNECTION_STATUS = 1;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_YES:
    WIFI_MGMR_CONNECTION_STATUS = 2;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_NO:
    WIFI_MGMR_CONNECTION_STATUS = 3;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_DISCONNECTED:
    WIFI_MGMR_CONNECTION_STATUS = 4;
pub type WIFI_MGMR_CONNECTION_STATUS = crate::binary::c_types::c_int;
pub use self::WIFI_MGMR_CONNECTION_STATUS as WIFI_MGMR_CONNECTION_STATUS_T;
#[repr(C, packed)]
pub struct wifi_mgmr_msg {
    pub ev: WIFI_MGMR_EVENT_T,
    pub data1: *mut crate::binary::c_types::c_void,
    pub data2: *mut crate::binary::c_types::c_void,
    pub len: u32,
    pub data: __IncompleteArrayField<u8>,
}
pub type wifi_mgmr_msg_t = wifi_mgmr_msg;
#[repr(C, packed)]
pub struct wifi_mgmr_cfg_element_msg {
    pub ops: u32,
    pub task: u32,
    pub element: u32,
    pub type_: u32,
    pub length: u32,
    pub buf: __IncompleteArrayField<u32>,
}
pub type wifi_mgmr_cfg_element_msg_t = wifi_mgmr_cfg_element_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_profile_msg {
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub ssid_len: u32,
    pub passphr: [crate::binary::c_types::c_char; 64usize],
    pub passphr_tail: [crate::binary::c_types::c_char; 1usize],
    pub psk: [crate::binary::c_types::c_char; 64usize],
    pub psk_tail: [crate::binary::c_types::c_char; 1usize],
    pub passphr_len: u32,
    pub psk_len: u32,
    pub bssid: [u8; 6usize],
    pub band: u8,
    pub freq: u16,
    pub ap_info_ttl: crate::binary::c_types::c_int,
}
pub type wifi_mgmr_profile_msg_t = wifi_mgmr_profile_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ipgot_msg {
    pub ip: u32,
    pub mask: u32,
    pub gw: u32,
    pub dns1: u32,
    pub dns2: u32,
}
pub type wifi_mgmr_ipgot_msg_t = wifi_mgmr_ipgot_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ap_msg {
    pub channel: i32,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub hidden_ssid: u8,
    pub ssid_len: u32,
    pub psk: [crate::binary::c_types::c_char; 64usize],
    pub psk_tail: [crate::binary::c_types::c_char; 1usize],
    pub psk_len: u32,
}
pub type wifi_mgmr_ap_msg_t = wifi_mgmr_ap_msg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_profile {
    pub ssid_len: u16,
    pub passphr_len: u16,
    pub psk_len: u16,
    pub ssid: [crate::binary::c_types::c_char; 33usize],
    pub passphr: [crate::binary::c_types::c_char; 65usize],
    pub psk: [crate::binary::c_types::c_char; 65usize],
    pub bssid: [u8; 6usize],
    pub band: u8,
    pub freq: u16,
    pub ap_info_ttl: crate::binary::c_types::c_int,
    pub priority: u8,
    pub isActive: u8,
    pub isUsed: u8,
}
pub type wifi_mgmr_profile_t = wifi_mgmr_profile;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_cipher_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_mgmr_cipher_t {
    #[inline]
    pub fn wep40(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep40(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wep104(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep104(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tkip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tkip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccmp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ccmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep40: u8,
        wep104: u8,
        tkip: u8,
        ccmp: u8,
        rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep40: u8 = unsafe { ::core::mem::transmute(wep40) };
            wep40 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wep104: u8 = unsafe { ::core::mem::transmute(wep104) };
            wep104 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tkip: u8 = unsafe { ::core::mem::transmute(tkip) };
            tkip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ccmp: u8 = unsafe { ::core::mem::transmute(ccmp) };
            ccmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsvd: u8 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_scan_item {
    pub timestamp_lastseen: u32,
    pub ssid_len: u16,
    pub channel: u8,
    pub rssi: i8,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub bssid: [u8; 6usize],
    pub ppm_abs: i8,
    pub ppm_rel: i8,
    pub auth: u8,
    pub cipher: u8,
    pub is_used: u8,
}
pub type wifi_mgmr_scan_item_t = wifi_mgmr_scan_item;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlan_netif {
    pub mode: crate::binary::c_types::c_int,
    pub vif_index: u8,
    pub mac: [u8; 6usize],
    pub opaque: *mut crate::binary::c_types::c_void,
    pub __bindgen_anon_1: wlan_netif__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wlan_netif__bindgen_ty_1 {
    pub sta: wlan_netif__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlan_netif__bindgen_ty_1__bindgen_ty_1 {
    pub rssi: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_scan_params {
    pub channel_num: u16,
    pub channels: [u16; 14usize],
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_end: crate::binary::c_types::c_char,
}
pub type wifi_mgmr_scan_params_t = wifi_mgmr_scan_params;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_connect_ind_stat_info {
    pub status_code: u16,
    pub reason_code: u16,
    pub chan_freq: u16,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub passphr: [crate::binary::c_types::c_char; 65usize],
    pub bssid: [u8; 6usize],
    pub type_ind: u8,
    pub chan_band: u8,
}
pub type wifi_mgmr_connect_ind_stat_info_t = wifi_mgmr_connect_ind_stat_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_sta_basic_info {
    pub sta_idx: u8,
    pub is_used: u8,
    pub sta_mac: [u8; 6usize],
    pub tsfhi: u32,
    pub tsflo: u32,
    pub rssi: crate::binary::c_types::c_int,
    pub data_rate: u8,
}
pub type wifi_mgmr_sta_basic_info_t = wifi_mgmr_sta_basic_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr {
    pub channel: crate::binary::c_types::c_int,
    pub inf_ap_enabled: crate::binary::c_types::c_int,
    pub wlan_sta: wlan_netif,
    pub wlan_ap: wlan_netif,
    pub status: WIFI_MGMR_CONNECTION_STATUS_T,
    pub profiles: [wifi_mgmr_profile_t; 1usize],
    pub profile_active_index: crate::binary::c_types::c_int,
    pub scan_items: [wifi_mgmr_scan_item_t; 50usize],
    pub mq_f: *mut crate::binary::c_types::c_void,
    pub m: stateMachine,
    pub timer: *mut crate::binary::c_types::c_void,
    pub wifi_mgmr_stat_info: wifi_mgmr_connect_ind_stat_info_t,
    pub ready: u8,
    pub country_code: [crate::binary::c_types::c_char; 3usize],
    pub disable_autoreconnect: u8,
    pub ap_bcn_int: u16,
    pub channel_nums: crate::binary::c_types::c_int,
    pub ap_info_ttl_curr: crate::binary::c_types::c_int,
    pub pending_task: wifi_mgmr__bindgen_ty_1,
    pub features: u32,
    pub scan_item_timeout: crate::binary::c_types::c_int,
    pub hostname: [crate::binary::c_types::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wifi_mgmr__bindgen_ty_1 {
    pub val: u32,
    pub bits: wifi_mgmr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct wifi_mgmr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl wifi_mgmr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn scan(&self) -> crate::binary::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan(&mut self, val: crate::binary::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_update(&self) -> crate::binary::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip_update(&mut self, val: crate::binary::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_got(&self) -> crate::binary::c_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ip_got(&mut self, val: crate::binary::c_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scan: crate::binary::c_types::c_uint,
        ip_update: crate::binary::c_types::c_uint,
        ip_got: crate::binary::c_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scan: u32 = unsafe { ::core::mem::transmute(scan) };
            scan as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ip_update: u32 = unsafe { ::core::mem::transmute(ip_update) };
            ip_update as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ip_got: u32 = unsafe { ::core::mem::transmute(ip_got) };
            ip_got as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type wifi_mgmr_t = wifi_mgmr;
extern "C" {
    pub fn wifi_mgmr_event_notify(msg: *mut wifi_mgmr_msg_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_state_get_internal(
        state: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_clean_internal() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_get_internal(
        s_code: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_set_country_code_internal(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_cnt_get_internal(sta_cnt: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_info_get_internal(
        sta_info_internal: *mut wifi_mgmr_sta_basic_info_t,
        idx: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_delete_internal(sta_idx: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_complete_notify() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub static mut wifiMgmr: wifi_mgmr_t;
}
extern "C" {
    pub fn wifi_mgmr_auth_to_str(auth: u8) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wifi_mgmr_cipher_to_str(cipher: u8) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_tsen_reload() -> crate::binary::c_types::c_int;
}
#[doc = " @file wifi_mgmr_api.h"]
#[doc = " Copyright (C) Bouffalo Lab 2016-2018"]
#[doc = ""]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_api_cipher_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_mgmr_api_cipher_t {
    #[inline]
    pub fn wep40(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep40(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wep104(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep104(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tkip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tkip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccmp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ccmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep40: u8,
        wep104: u8,
        tkip: u8,
        ccmp: u8,
        rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep40: u8 = unsafe { ::core::mem::transmute(wep40) };
            wep40 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wep104: u8 = unsafe { ::core::mem::transmute(wep104) };
            wep104 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tkip: u8 = unsafe { ::core::mem::transmute(tkip) };
            tkip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ccmp: u8 = unsafe { ::core::mem::transmute(ccmp) };
            ccmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsvd: u8 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn wifi_mgmr_api_common_msg(
        ev: WIFI_MGMR_EVENT_T,
        data1: *mut crate::binary::c_types::c_void,
        data2: *mut crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_connect(
        ssid: *mut crate::binary::c_types::c_char,
        passphr: *mut crate::binary::c_types::c_char,
        ext_param: *const ap_connect_adv_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_cfg_req(
        ops: u32,
        task: u32,
        element: u32,
        type_: u32,
        length: u32,
        buf: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ip_got(
        ip: u32,
        mask: u32,
        gw: u32,
        dns1: u32,
        dns2: u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ip_update() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_reconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_rate_config(config: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_conf_max_sta(max_sta_supported: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ifaceup() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_sniffer_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ap_start(
        ssid: *mut crate::binary::c_types::c_char,
        passwd: *mut crate::binary::c_types::c_char,
        channel: crate::binary::c_types::c_int,
        hidden_ssid: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ap_stop() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_idle() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_channel_set(
        channel: crate::binary::c_types::c_int,
        use_40Mhz: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_raw_send(
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_set_country_code(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_scan(
        channels: *mut u16,
        channel_num: u16,
        ssid: *const crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_powersaving(
        mode: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_disable_autoreconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_enable_autoreconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_denoise_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_denoise_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_scan_item_beacon(
        channel: u8,
        rssi: i8,
        auth: u8,
        mac: *mut u8,
        ssid: *mut u8,
        len: crate::binary::c_types::c_int,
        ppm_abs: i8,
        ppm_rel: i8,
        cipher: u8,
    ) -> crate::binary::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
