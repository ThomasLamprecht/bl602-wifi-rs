/* automatically generated by rust-bindgen 0.58.1 */

#![allow(
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    dead_code
)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const WIFI_MGMR_DEFAULT_CLOCK_ID: u32 = 0;
pub const WIFI_MGMR_CMD_QUEUE_NAME: &'static [u8; 6usize] = b"/wlmq\0";
pub const CODE_WIFI_ON_INIT_DONE: u32 = 1;
pub const CODE_WIFI_ON_MGMR_DONE: u32 = 2;
pub const CODE_WIFI_CMD_RECONNECT: u32 = 3;
pub const CODE_WIFI_ON_CONNECTED: u32 = 4;
pub const CODE_WIFI_ON_DISCONNECT: u32 = 5;
pub const CODE_WIFI_ON_PRE_GOT_IP: u32 = 6;
pub const CODE_WIFI_ON_GOT_IP: u32 = 7;
pub const CODE_WIFI_ON_CONNECTING: u32 = 8;
pub const CODE_WIFI_ON_SCAN_DONE: u32 = 9;
pub const CODE_WIFI_ON_SCAN_DONE_ONJOIN: u32 = 10;
pub const CODE_WIFI_ON_AP_STARTED: u32 = 11;
pub const CODE_WIFI_ON_AP_STOPPED: u32 = 12;
pub const CODE_WIFI_ON_PROV_SSID: u32 = 13;
pub const CODE_WIFI_ON_PROV_BSSID: u32 = 14;
pub const CODE_WIFI_ON_PROV_PASSWD: u32 = 15;
pub const CODE_WIFI_ON_PROV_CONNECT: u32 = 16;
pub const CODE_WIFI_ON_PROV_DISCONNECT: u32 = 17;
pub const CODE_WIFI_ON_PROV_SCAN_START: u32 = 18;
pub const CODE_WIFI_ON_PROV_STATE_GET: u32 = 19;
pub const CODE_WIFI_ON_MGMR_DENOISE: u32 = 20;
pub const CODE_WIFI_ON_AP_STA_ADD: u32 = 21;
pub const CODE_WIFI_ON_AP_STA_DEL: u32 = 22;
pub const CODE_WIFI_ON_EMERGENCY_MAC: u32 = 23;
pub const CODE_ON_DISCONNECT: u32 = 5;
pub const CODE_ON_GOT_IP: u32 = 7;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const WIFI_MGMR_SCAN_ITEMS_MAX: u32 = 50;
pub const WIFI_MGMR_PROFILES_MAX: u32 = 1;
pub const WIFI_MGMR_MQ_MSG_SIZE: u32 = 224;
pub const WIFI_MGMR_MQ_MSG_COUNT: u32 = 1;
pub const WIFI_MGMR_CONNECT_IND_STAT_INFO_TYPE_IND_CONNECTION: u32 = 1;
pub const WIFI_MGMR_CONNECT_IND_STAT_INFO_TYPE_IND_DISCONNECTION: u32 = 2;
pub const WIFI_MGMR_PENDING_TASK_SCAN_BIT: u32 = 1;
pub const WIFI_MGMR_FEATURES_SCAN_SAVE_HIDDEN_SSID: u32 = 1;
pub const WIFI_MGMR_CONFIG_SCAN_ITEM_TIMEOUT: u32 = 15000;
pub const MAX_HOSTNAME_LEN_CHECK: u32 = 32;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_OFF: u32 = 1;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_ON: u32 = 2;
pub const WIFI_MGMR_API_FW_POWERSAVING_MODE_DYNAMIC_ON: u32 = 3;
pub type va_list = *mut crate::binary::c_types::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut crate::binary::c_types::c_char, ...);
}
pub type size_t = crate::binary::c_types::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = crate::binary::c_types::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = crate::binary::c_types::c_schar;
pub type int_least16_t = crate::binary::c_types::c_short;
pub type int_least32_t = crate::binary::c_types::c_int;
pub type int_least64_t = crate::binary::c_types::c_longlong;
pub type uint_least8_t = crate::binary::c_types::c_uchar;
pub type uint_least16_t = crate::binary::c_types::c_ushort;
pub type uint_least32_t = crate::binary::c_types::c_uint;
pub type uint_least64_t = crate::binary::c_types::c_ulonglong;
pub type int_fast8_t = crate::binary::c_types::c_schar;
pub type int_fast16_t = crate::binary::c_types::c_int;
pub type int_fast32_t = crate::binary::c_types::c_int;
pub type int_fast64_t = crate::binary::c_types::c_longlong;
pub type uint_fast8_t = crate::binary::c_types::c_uchar;
pub type uint_fast16_t = crate::binary::c_types::c_uint;
pub type uint_fast32_t = crate::binary::c_types::c_uint;
pub type uint_fast64_t = crate::binary::c_types::c_ulonglong;
pub type intmax_t = crate::binary::c_types::c_longlong;
pub type uintmax_t = crate::binary::c_types::c_ulonglong;
extern "C" {
    pub fn os_get_time_ms() -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct os_event {
    pub type_: crate::binary::c_types::c_int,
    pub value: *mut crate::binary::c_types::c_void,
}
pub type os_event_t = *mut os_event;
extern "C" {
    pub fn os_api_init() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn os_event_notify(arg1: os_event_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn os_lock_giant();
}
extern "C" {
    pub fn os_unlock_giant();
}
extern "C" {
    pub fn msleep(msec: crate::binary::c_types::c_long) -> crate::binary::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ap_item {
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub ssid_len: u32,
    pub bssid: [u8; 6usize],
    pub channel: u8,
    pub auth: u8,
    pub rssi: i8,
}
pub type wifi_mgmr_ap_item_t = wifi_mgmr_ap_item;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_sta_connect_ind_stat_info {
    pub status_code: u16,
    pub type_ind: u8,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub psk: [crate::binary::c_types::c_char; 65usize],
    pub pmk: [crate::binary::c_types::c_char; 64usize],
    pub bssid: [u8; 6usize],
    pub chan_freq: u16,
    pub chan_band: u8,
}
pub type wifi_mgmr_sta_connect_ind_stat_info_t = wifi_mgmr_sta_connect_ind_stat_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_sta_basic_info {
    pub sta_idx: u8,
    pub is_used: u8,
    pub sta_mac: [u8; 6usize],
    pub tsfhi: u32,
    pub tsflo: u32,
    pub rssi: crate::binary::c_types::c_int,
    pub data_rate: u8,
}
pub type wifi_sta_basic_info_t = wifi_sta_basic_info;
pub type wifi_interface_t = *mut crate::binary::c_types::c_void;
pub type sniffer_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        env: *mut crate::binary::c_types::c_void,
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ),
>;
pub type scan_item_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        env: *mut wifi_mgmr_ap_item_t,
        param1: *mut u32,
        item: *mut wifi_mgmr_ap_item_t,
    ),
>;
pub type scan_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut crate::binary::c_types::c_void,
        param: *mut crate::binary::c_types::c_void,
    ),
>;
#[doc = " Power-save off"]
pub const PS_MODE_OFF: crate::binary::c_types::c_int = 0;
#[doc = " Power-save on - Normal mode"]
pub const PS_MODE_ON: crate::binary::c_types::c_int = 1;
#[doc = " Power-save on - Dynamic mode"]
pub const PS_MODE_ON_DYN: crate::binary::c_types::c_int = 2;
#[doc = " Power Save mode setting"]
pub type _bindgen_ty_1 = crate::binary::c_types::c_int;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_UNKNOWN: WIFI_STATE_ENUM_LIST = 0;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_IDLE: WIFI_STATE_ENUM_LIST = 1;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTING: WIFI_STATE_ENUM_LIST = 2;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTED_IP_GETTING: WIFI_STATE_ENUM_LIST = 3;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_CONNECTED_IP_GOT: WIFI_STATE_ENUM_LIST = 4;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_DISCONNECT: WIFI_STATE_ENUM_LIST = 5;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_IDLE: WIFI_STATE_ENUM_LIST = 17;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTING: WIFI_STATE_ENUM_LIST = 18;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTED_IP_GETTING: WIFI_STATE_ENUM_LIST = 19;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_CONNECTED_IP_GOT: WIFI_STATE_ENUM_LIST = 20;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_WITH_AP_DISCONNECT: WIFI_STATE_ENUM_LIST = 21;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_IFDOWN: WIFI_STATE_ENUM_LIST = 6;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_SNIFFER: WIFI_STATE_ENUM_LIST = 7;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_PSK_ERROR: WIFI_STATE_ENUM_LIST = 8;
pub const WIFI_STATE_ENUM_LIST_WIFI_STATE_NO_AP_FOUND: WIFI_STATE_ENUM_LIST = 9;
pub type WIFI_STATE_ENUM_LIST = crate::binary::c_types::c_int;
pub const WIFI_SCAN_DONE_EVENT_TYPE_WIFI_SCAN_DONE_EVENT_OK: WIFI_SCAN_DONE_EVENT_TYPE = 0;
pub const WIFI_SCAN_DONE_EVENT_TYPE_WIFI_SCAN_DONE_EVENT_BUSY: WIFI_SCAN_DONE_EVENT_TYPE = 1;
pub type WIFI_SCAN_DONE_EVENT_TYPE = crate::binary::c_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_conf {
    pub country_code: [crate::binary::c_types::c_char; 3usize],
    pub channel_nums: crate::binary::c_types::c_int,
}
pub type wifi_conf_t = wifi_conf;
extern "C" {
    pub fn wifi_mgmr_psk_cal(
        password: *mut crate::binary::c_types::c_char,
        ssid: *mut crate::binary::c_types::c_char,
        ssid_len: crate::binary::c_types::c_int,
        output: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_drv_init(conf: *mut wifi_conf_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_init() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_start();
}
extern "C" {
    pub fn wifi_mgmr_start_background(conf: *mut wifi_conf_t);
}
extern "C" {
    pub fn wifi_mgmr_get_wifi_channel_conf(wifi_chan_conf: *mut wifi_conf_t);
}
extern "C" {
    pub fn wifi_mgmr_sta_enable() -> wifi_interface_t;
}
extern "C" {
    pub fn wifi_mgmr_sta_disable(interface: *mut wifi_interface_t)
        -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_mac_set(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_mac_get(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_get(
        ip: *mut u32,
        gw: *mut u32,
        mask: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_set(
        ip: u32,
        mask: u32,
        gw: u32,
        dns1: u32,
        dns2: u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_dns_get(dns1: *mut u32, dns2: *mut u32) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ip_unset() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_connect(
        wifi_interface: *mut wifi_interface_t,
        ssid: *mut crate::binary::c_types::c_char,
        psk: *mut crate::binary::c_types::c_char,
        pmk: *mut crate::binary::c_types::c_char,
        mac: *mut u8,
        band: u8,
        freq: u16,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_powersaving(
        ps: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_autoconnect_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_autoconnect_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sta_ssid_set(ssid: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn wifi_mgmr_sta_psk_set(psk: *mut crate::binary::c_types::c_char);
}
extern "C" {
    pub fn wifi_mgmr_sta_connect_ind_stat_get(
        wifi_mgmr_ind_stat: *mut wifi_mgmr_sta_connect_ind_stat_info_t,
    );
}
extern "C" {
    pub fn wifi_mgmr_ap_enable() -> wifi_interface_t;
}
extern "C" {
    pub fn wifi_mgmr_ap_mac_set(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_mac_get(mac: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_ip_get(
        ip: *mut u32,
        gw: *mut u32,
        mask: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_stop(interface: *mut wifi_interface_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_start(
        interface: *mut wifi_interface_t,
        ssid: *mut crate::binary::c_types::c_char,
        hidden_ssid: crate::binary::c_types::c_int,
        passwd: *mut crate::binary::c_types::c_char,
        channel: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_cnt_get(sta_cnt: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_info_get(
        sta_info: *mut wifi_sta_basic_info,
        idx: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_delete(sta_idx: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_set_gateway(
        gateway: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_rate_config(config: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_conf_max_sta(max_sta_supported: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_register(
        env: *mut crate::binary::c_types::c_void,
        cb: sniffer_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_sniffer_unregister(
        env: *mut crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_state_get(
        state: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_get(
        s_code: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_rssi_get(
        rssi: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_channel_get(
        channel: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_channel_set(
        channel: crate::binary::c_types::c_int,
        use_40Mhz: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_all_ap_scan(
        ap_ary: *mut *mut wifi_mgmr_ap_item_t,
        num: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_filter_hidden_ssid(
        filter: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan(
        data: *mut crate::binary::c_types::c_void,
        cb: scan_complete_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cfg_req(
        ops: u32,
        task: u32,
        element: u32,
        type_: u32,
        length: u32,
        buf: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_complete_callback() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cli_scanlist() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_cli_init() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_ap(
        ssid: *mut crate::binary::c_types::c_char,
        item: *mut wifi_mgmr_ap_item_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_ap_all(
        env: *mut wifi_mgmr_ap_item_t,
        param1: *mut u32,
        cb: scan_item_cb_t,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_raw_80211_send(
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_set_country_code(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ext_dump_needed() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_str(status_code: u16) -> *const crate::binary::c_types::c_char;
}
pub type max_align_t = f64;
#[doc = " \\brief Event"]
#[doc = ""]
#[doc = " Events trigger transitions from a state to another. Event types are defined"]
#[doc = " by the user. Any event may optionally contain a \\ref #event::data"]
#[doc = " \"payload\"."]
#[doc = ""]
#[doc = " \\sa state"]
#[doc = " \\sa transition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct event {
    #[doc = " \\brief Type of event. Defined by user."]
    pub type_: crate::binary::c_types::c_int,
    #[doc = " \\brief Event payload."]
    #[doc = ""]
    #[doc = " How this is used is entirely up to the user. This data"]
    #[doc = " is always passed together with #type in order to make it possible to"]
    #[doc = " always cast the data correctly."]
    pub data: *mut crate::binary::c_types::c_void,
}
#[doc = " \\brief Transition between a state and another state"]
#[doc = ""]
#[doc = " All states that are not final must have at least one transition. The"]
#[doc = " transition may be guarded or not. Transitions are triggered by events. If"]
#[doc = " a state has more than one transition with the same type of event (and the"]
#[doc = " same condition), the first transition in the array will be run. An"]
#[doc = " unconditional transition placed last in the transition array of a state can"]
#[doc = " act as a \"catch-all\". A transition may optionally run an #action, which"]
#[doc = " will have the triggering event passed to it as an argument, along with the"]
#[doc = " current and new states' \\ref state::data \"data\"."]
#[doc = ""]
#[doc = " It is perfectly valid for a transition to return to the state it belongs"]
#[doc = " to. Such a transition will not call the state's \\ref state::entryAction"]
#[doc = " \"entry action\" or \\ref state::exitAction \"exit action\". If there are no"]
#[doc = " transitions for the current event, the state's parent will be handed the"]
#[doc = " event."]
#[doc = ""]
#[doc = " ### Examples ###"]
#[doc = " - An ungarded transition to a state with no action performed:"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_timeout,"]
#[doc = "    .condition = NULL,"]
#[doc = "    .guard = NULL,"]
#[doc = "    .action = NULL,"]
#[doc = "    .nextState = &mainMenuState,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " - A guarded transition executing an action"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_keyboard,"]
#[doc = "    .condition = NULL,"]
#[doc = "    .guard = &ensureNumericInput,"]
#[doc = "    .action = &addToBuffer,"]
#[doc = "    .nextState = &awaitingInputState,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " - A guarded transition using a condition"]
#[doc = " ~~~{.c}"]
#[doc = " {"]
#[doc = "    .eventType = Event_mouse,"]
#[doc = "    .condition = boxLimits,"]
#[doc = "    .guard = &coordinatesWithinLimits,"]
#[doc = " },"]
#[doc = " ~~~"]
#[doc = " By using \\ref #condition \"conditions\" a more general guard function can be"]
#[doc = " used, operating on the supplied argument #condition. In this example,"]
#[doc = " `coordinatesWithinLimits` checks whether the coordinates in the mouse event"]
#[doc = " are within the limits of the \"box\"."]
#[doc = ""]
#[doc = " \\sa event"]
#[doc = " \\sa state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct transition {
    #[doc = " \\brief The event that will trigger this transition."]
    pub eventType: crate::binary::c_types::c_int,
    #[doc = " \\brief Condition that event must fulfil"]
    #[doc = ""]
    #[doc = " This variable will be passed to the #guard (if #guard is non-NULL) and"]
    #[doc = " may be used as a condition that the incoming event's data must fulfil in"]
    #[doc = " order for the transition to be performed. By using this variable, the"]
    #[doc = " number of #guard functions can be minimised by making them more general."]
    pub condition: *mut crate::binary::c_types::c_void,
    #[doc = " \\brief Check if data passed with event fulfils a condition"]
    #[doc = ""]
    #[doc = " A transition may be conditional. If so, this function, if non-NULL, will"]
    #[doc = " be called. Its first argument will be supplied with #condition, which"]
    #[doc = " can be compared against the \\ref event::data \"payload\" in the #event."]
    #[doc = " The user may choose to use this argument or not. Only if the result is"]
    #[doc = " true, the transition will take place."]
    #[doc = ""]
    #[doc = " \\param condition event (data) to compare the incoming event against."]
    #[doc = " \\param event the event passed to the state machine."]
    #[doc = ""]
    #[doc = " \\returns true if the event's data fulfils the condition, otherwise false."]
    pub guard: ::core::option::Option<
        unsafe extern "C" fn(
            condition: *mut crate::binary::c_types::c_void,
            event: *mut event,
        ) -> bool,
    >,
    #[doc = " \\brief Function containing tasks to be performed during the transition"]
    #[doc = ""]
    #[doc = " The transition may optionally do some work in this function before"]
    #[doc = " entering the next state. May be NULL."]
    #[doc = ""]
    #[doc = " \\param currentStateData the leaving state's \\ref state::data \"data\""]
    #[doc = " \\param event the event passed to the state machine."]
    #[doc = " \\param newStateData the new state's (the \\ref state::entryState"]
    #[doc = " \"entryState\" of any (chain of) parent states, not the parent state"]
    #[doc = " itself) \\ref state::data \"data\""]
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            currentStateData: *mut crate::binary::c_types::c_void,
            event: *mut event,
            newStateData: *mut crate::binary::c_types::c_void,
        ),
    >,
    #[doc = " \\brief The next state"]
    #[doc = ""]
    #[doc = " This must point to the next state that will be entered. It cannot be"]
    #[doc = " NULL. If it is, the state machine will detect it and enter the \\ref"]
    #[doc = " stateMachine::errorState \"error state\"."]
    pub nextState: *const state,
}
#[doc = " \\brief State"]
#[doc = ""]
#[doc = " The current state in a state machine moves to a new state when one of the"]
#[doc = " #transitions in the current state triggers on an event. An optional \\ref"]
#[doc = " #exitAction \"exit action\" is called when the state is left, and an \\ref"]
#[doc = " #entryAction \"entry action\" is called when the state machine enters a new"]
#[doc = " state. If a state returns to itself, neither #exitAction nor #entryAction"]
#[doc = " will be called. An optional \\ref transition::action \"transition action\" is"]
#[doc = " called in either case."]
#[doc = ""]
#[doc = " States may be organised in a hierarchy by setting \\ref #parentState"]
#[doc = " \"parent states\". When a group/parent state is entered, the state machine is"]
#[doc = " redirected to the group state's \\ref #entryState \"entry state\" (if"]
#[doc = " non-NULL). If an event does not trigger a transition in a state and if the"]
#[doc = " state has a parent state, the event will be passed to the parent state."]
#[doc = " This behaviour is repeated for all parents. Thus all children of a state"]
#[doc = " have a set of common #transitions. A parent state's #entryAction will not"]
#[doc = " be called if an event is passed on to a child state."]
#[doc = ""]
#[doc = " The following lists the different types of states that may be created, and"]
#[doc = " how to create them:"]
#[doc = ""]
#[doc = " ### Normal state ###"]
#[doc = " ~~~{.c}"]
#[doc = " struct state normalState = {"]
#[doc = "    .parentState = &groupState,"]
#[doc = "    .entryState = NULL,"]
#[doc = "    .transition = (struct transition[]){"]
#[doc = "       { Event_keyboard, (void *)(intptr_t)'\\n', &compareKeyboardChar,"]
#[doc = "          NULL, &msgReceivedState },"]
#[doc = "    },"]
#[doc = "    .numTransitions = 1,"]
#[doc = "    .data = normalStateData,"]
#[doc = "    .entryAction = &doSomething,"]
#[doc = "    .exitAction = &cleanUp,"]
#[doc = " };"]
#[doc = " ~~~"]
#[doc = " In this example, `normalState` is a child of `groupState`, but the"]
#[doc = " #parentState value may also be NULL to indicate that it is not a child of"]
#[doc = " any group state."]
#[doc = ""]
#[doc = " ### Group/parent state ###"]
#[doc = " A state becomes a group/parent state when it is linked to by child states"]
#[doc = " by using #parentState. No members in the group state need to be set in a"]
#[doc = " particular way. A parent state may also have a parent."]
#[doc = " ~~~{.c}"]
#[doc = " struct state groupState = {"]
#[doc = "    .entryState = &normalState,"]
#[doc = "    .entryAction = NULL,"]
#[doc = " ~~~"]
#[doc = " If there are any transitions in the state machine that lead to a group"]
#[doc = " state, it makes sense to define an entry state in the group. This can be"]
#[doc = " done by using #entryState, but it is not mandatory. If the #entryState"]
#[doc = " state has children, the chain of children will be traversed until a child"]
#[doc = " with its #entryState set to NULL is found."]
#[doc = ""]
#[doc = " \\note If #entryState is defined for a group state, the group state's"]
#[doc = " #entryAction will not be called (the state pointed to by #entryState (after"]
#[doc = " following the chain of children), however, will have its #entryAction"]
#[doc = " called)."]
#[doc = ""]
#[doc = " \\warning The state machine cannot detect cycles in parent chains and"]
#[doc = " children chains. If such cycles are present, stateM_handleEvent() will"]
#[doc = " never finish due to never-ending loops."]
#[doc = ""]
#[doc = " ### Final state ###"]
#[doc = " A final state is a state that terminates the state machine. A state is"]
#[doc = " considered as a final state if its #numTransitions is 0:"]
#[doc = " ~~~{.c}"]
#[doc = " struct state finalState = {"]
#[doc = "    .transitions = NULL,"]
#[doc = "    .numTransitions = 0,"]
#[doc = " ~~~"]
#[doc = " The error state used by the state machine to indicate errors should be a"]
#[doc = " final state. Any calls to stateM_handleEvent() when the current state is a"]
#[doc = " final state will return #stateM_noStateChange."]
#[doc = ""]
#[doc = " \\sa event"]
#[doc = " \\sa transition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct state {
    #[doc = " \\brief If the state has a parent state, this pointer must be non-NULL."]
    pub parentState: *const state,
    #[doc = " \\brief If this state is a parent state, this pointer may point to a"]
    #[doc = " child state that serves as an entry point."]
    pub entryState: *const state,
    #[doc = " \\brief An array of transitions for the state."]
    pub transitions: *mut transition,
    #[doc = " \\brief Number of transitions in the #transitions array."]
    pub numTransitions: size_t,
    #[doc = " \\brief Data that will be available for the state in its #entryAction and"]
    #[doc = " #exitAction, and in any \\ref transition::action \"transition action\""]
    pub data: *mut crate::binary::c_types::c_void,
    #[doc = " \\brief This function is called whenever the state is being entered. May"]
    #[doc = " be NULL."]
    #[doc = ""]
    #[doc = " \\note If a state returns to itself through a transition (either directly"]
    #[doc = " or through a parent/group sate), its #entryAction will not be called."]
    #[doc = ""]
    #[doc = " \\note A group/parent state with its #entryState defined will not have"]
    #[doc = " its #entryAction called."]
    #[doc = ""]
    #[doc = " \\param stateData the state's #data will be passed."]
    #[doc = " \\param event the event that triggered the transition will be passed."]
    pub entryAction: ::core::option::Option<
        unsafe extern "C" fn(stateData: *mut crate::binary::c_types::c_void, event: *mut event),
    >,
    #[doc = " \\brief This function is called whenever the state is being left. May be"]
    #[doc = " NULL."]
    #[doc = ""]
    #[doc = " \\note If a state returns to itself through a transition (either directly"]
    #[doc = " or through a parent/group sate), its #exitAction will not be called."]
    #[doc = ""]
    #[doc = " \\param stateData the state's #data will be passed."]
    #[doc = " \\param event the event that triggered a transition will be passed."]
    pub exitAction: ::core::option::Option<
        unsafe extern "C" fn(stateData: *mut crate::binary::c_types::c_void, event: *mut event),
    >,
}
#[doc = " \\brief State machine"]
#[doc = ""]
#[doc = " There is no need to manipulate the members directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct stateMachine {
    #[doc = " \\brief Pointer to the current state"]
    pub currentState: *const state,
    #[doc = " \\brief Pointer to previous state"]
    #[doc = ""]
    #[doc = " The previous state is stored for convenience in case the user needs to"]
    #[doc = " keep track of previous states."]
    pub previousState: *const state,
    #[doc = " \\brief Pointer to a state that will be entered whenever an error occurs"]
    #[doc = " in the state machine."]
    #[doc = ""]
    #[doc = " See #stateM_errorStateReached for when the state machine enters the"]
    #[doc = " error state."]
    pub errorState: *const state,
}
extern "C" {
    #[doc = " \\brief Initialise the state machine"]
    #[doc = ""]
    #[doc = " This function initialises the supplied stateMachine and sets the current"]
    #[doc = " state to \\pn{initialState}. No actions are performed until"]
    #[doc = " stateM_handleEvent() is called. It is safe to call this function numerous"]
    #[doc = " times, for instance in order to reset/restart the state machine if a final"]
    #[doc = " state has been reached."]
    #[doc = ""]
    #[doc = " \\note The \\ref #state::entryAction \"entry action\" for \\pn{initialState}"]
    #[doc = " will not be called."]
    #[doc = ""]
    #[doc = " \\note If \\pn{initialState} is a parent state with its \\ref"]
    #[doc = " state::entryState \"entryState\" defined, it will not be entered. The user"]
    #[doc = " must explicitly set the initial state."]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to initialise."]
    #[doc = " \\param initialState the initial state of the state machine."]
    #[doc = " \\param errorState pointer to a state that acts a final state and notifies"]
    #[doc = " the system/user that an error has occurred."]
    pub fn stateM_init(
        stateMachine: *mut stateMachine,
        initialState: *const state,
        errorState: *const state,
    );
}
#[doc = " \\brief Erroneous arguments were passed"]
pub const stateM_handleEventRetVals_stateM_errArg: stateM_handleEventRetVals = -2;
#[doc = " \\brief The error state was reached"]
#[doc = ""]
#[doc = " This value is returned either when the state machine enters the error"]
#[doc = " state itself as a result of an error, or when the error state is the"]
#[doc = " next state as a result of a successful transition."]
#[doc = ""]
#[doc = " The state machine enters the state machine if any of the following"]
#[doc = " happens:"]
#[doc = " - The current state is NULL"]
#[doc = " - A transition for the current event did not define the next state"]
pub const stateM_handleEventRetVals_stateM_errorStateReached: stateM_handleEventRetVals = -1;
#[doc = " \\brief The current state changed into a non-final state"]
pub const stateM_handleEventRetVals_stateM_stateChanged: stateM_handleEventRetVals = 0;
#[doc = " \\brief The state changed back to itself"]
#[doc = ""]
#[doc = " The state can return to itself either directly or indirectly. An"]
#[doc = " indirect path may inlude a transition from a parent state and the use of"]
#[doc = " \\ref state::entryState \"entryStates\"."]
pub const stateM_handleEventRetVals_stateM_stateLoopSelf: stateM_handleEventRetVals = 1;
#[doc = " \\brief The current state did not change on the given event"]
#[doc = ""]
#[doc = " If any event passed to the state machine should result in a state"]
#[doc = " change, this return value should be considered as an error."]
pub const stateM_handleEventRetVals_stateM_noStateChange: stateM_handleEventRetVals = 2;
#[doc = " \\brief A final state (any but the error state) was reached"]
pub const stateM_handleEventRetVals_stateM_finalStateReached: stateM_handleEventRetVals = 3;
#[doc = " \\brief stateM_handleEvent() return values"]
pub type stateM_handleEventRetVals = crate::binary::c_types::c_int;
extern "C" {
    #[doc = " \\brief Pass an event to the state machine"]
    #[doc = ""]
    #[doc = " The event will be passed to the current state, and possibly to the current"]
    #[doc = " state's parent states (if any). If the event triggers a transition, a new"]
    #[doc = " state will be entered. If the transition has an \\ref transition::action"]
    #[doc = " \"action\" defined, it will be called. If the transition is to a state other"]
    #[doc = " than the current state, the current state's \\ref state::exitAction"]
    #[doc = " \"exit action\" is called (if defined). Likewise, if the state is a new"]
    #[doc = " state, the new state's \\ref state::entryAction \"entry action\" is called (if"]
    #[doc = " defined)."]
    #[doc = ""]
    #[doc = " The returned value is negative if an error occurs."]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to pass an event to."]
    #[doc = " \\param event the event to be handled."]
    #[doc = ""]
    #[doc = " \\return #stateM_handleEventRetVals"]
    pub fn stateM_handleEvent(
        stateMachine: *mut stateMachine,
        event: *mut event,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current state"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to get the current state from."]
    #[doc = ""]
    #[doc = " \\retval a pointer to the current state."]
    #[doc = " \\retval NULL if \\pn{stateMachine} is NULL."]
    pub fn stateM_currentState(stateMachine: *mut stateMachine) -> *const state;
}
extern "C" {
    #[doc = " \\brief Get the previous state"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to get the previous state from."]
    #[doc = ""]
    #[doc = " \\retval the previous state."]
    #[doc = " \\retval NULL if \\pn{stateMachine} is NULL."]
    #[doc = " \\retval NULL if there has not yet been any transitions."]
    pub fn stateM_previousState(stateMachine: *mut stateMachine) -> *const state;
}
extern "C" {
    #[doc = " \\brief Check if the state machine has stopped"]
    #[doc = ""]
    #[doc = " \\param stateMachine the state machine to test."]
    #[doc = ""]
    #[doc = " \\retval true if the state machine has reached a final state."]
    #[doc = " \\retval false if \\pn{stateMachine} is NULL or if the current state is not a"]
    #[doc = " final state."]
    pub fn stateM_stopped(stateMachine: *mut stateMachine) -> bool;
}
pub const EVENT_TYPE_EVENT_TYPE_FW: EVENT_TYPE = 0;
pub const EVENT_TYPE_EVENT_TYPE_APP: EVENT_TYPE = 1;
pub const EVENT_TYPE_EVENT_TYPE_GLB: EVENT_TYPE = 2;
#[doc = " @file wifi_mgmr.h"]
#[doc = " Copyright (C) Bouffalo Lab 2016-2018"]
#[doc = ""]
#[doc = ""]
pub type EVENT_TYPE = crate::binary::c_types::c_int;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_IDLE: WIFI_MGMR_EVENT = 0;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONNECT: WIFI_MGMR_EVENT = 1;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_SNIFFER: WIFI_MGMR_EVENT = 2;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONNECTED: WIFI_MGMR_EVENT = 3;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_IP_GOT: WIFI_MGMR_EVENT = 4;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_DISCONNECT: WIFI_MGMR_EVENT = 5;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RECONNECT: WIFI_MGMR_EVENT = 6;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_PHY_UP: WIFI_MGMR_EVENT = 7;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_AP_START: WIFI_MGMR_EVENT = 8;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_AP_STOP: WIFI_MGMR_EVENT = 9;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_CONF_MAX_STA: WIFI_MGMR_EVENT = 10;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RC_CONFIG: WIFI_MGMR_EVENT = 11;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_DENOISE: WIFI_MGMR_EVENT = 12;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_APP_RELOAD_TSEN: WIFI_MGMR_EVENT = 13;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_MAXAPP_MINIFW: WIFI_MGMR_EVENT = 14;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_DISCONNECT: WIFI_MGMR_EVENT = 15;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_POWERSAVING: WIFI_MGMR_EVENT = 16;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_CHANNEL_SET: WIFI_MGMR_EVENT = 17;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_SCAN: WIFI_MGMR_EVENT = 18;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_IND_DISCONNECT: WIFI_MGMR_EVENT = 19;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_IND_CONNECTED: WIFI_MGMR_EVENT = 20;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_DATA_RAW_SEND: WIFI_MGMR_EVENT = 21;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_FW_CFG_REQ: WIFI_MGMR_EVENT = 22;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_MAXFW_MINI_GLOBAL: WIFI_MGMR_EVENT = 23;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_SCAN_IND_BEACON: WIFI_MGMR_EVENT = 24;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_SCAN_IND_PROBE_RESP: WIFI_MGMR_EVENT = 25;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_AP_IND_STA_NEW: WIFI_MGMR_EVENT = 26;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_AP_IND_STA_DEL: WIFI_MGMR_EVENT = 27;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_DISABLE_AUTORECONNECT: WIFI_MGMR_EVENT = 28;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_ENABLE_AUTORECONNECT: WIFI_MGMR_EVENT = 29;
pub const WIFI_MGMR_EVENT_WIFI_MGMR_EVENT_GLB_IP_UPDATE: WIFI_MGMR_EVENT = 30;
pub type WIFI_MGMR_EVENT = crate::binary::c_types::c_int;
pub use self::WIFI_MGMR_EVENT as WIFI_MGMR_EVENT_T;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_IDLE:
    WIFI_MGMR_CONNECTION_STATUS = 0;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTING:
    WIFI_MGMR_CONNECTION_STATUS = 1;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_YES:
    WIFI_MGMR_CONNECTION_STATUS = 2;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_CONNECTED_IP_NO:
    WIFI_MGMR_CONNECTION_STATUS = 3;
pub const WIFI_MGMR_CONNECTION_STATUS_WIFI_MGMR_CONNECTION_STATUS_DISCONNECTED:
    WIFI_MGMR_CONNECTION_STATUS = 4;
pub type WIFI_MGMR_CONNECTION_STATUS = crate::binary::c_types::c_int;
pub use self::WIFI_MGMR_CONNECTION_STATUS as WIFI_MGMR_CONNECTION_STATUS_T;
#[repr(C, packed)]
pub struct wifi_mgmr_msg {
    pub ev: WIFI_MGMR_EVENT_T,
    pub data1: *mut crate::binary::c_types::c_void,
    pub data2: *mut crate::binary::c_types::c_void,
    pub len: u32,
    pub data: __IncompleteArrayField<u8>,
}
pub type wifi_mgmr_msg_t = wifi_mgmr_msg;
#[repr(C, packed)]
pub struct wifi_mgmr_cfg_element_msg {
    pub ops: u32,
    pub task: u32,
    pub element: u32,
    pub type_: u32,
    pub length: u32,
    pub buf: __IncompleteArrayField<u32>,
}
pub type wifi_mgmr_cfg_element_msg_t = wifi_mgmr_cfg_element_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_profile_msg {
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub ssid_len: u32,
    pub psk: [crate::binary::c_types::c_char; 64usize],
    pub psk_tail: [crate::binary::c_types::c_char; 1usize],
    pub pmk: [crate::binary::c_types::c_char; 64usize],
    pub pmk_tail: [crate::binary::c_types::c_char; 1usize],
    pub psk_len: u32,
    pub pmk_len: u32,
    pub mac: [u8; 6usize],
    pub band: u8,
    pub freq: u16,
}
pub type wifi_mgmr_profile_msg_t = wifi_mgmr_profile_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ipgot_msg {
    pub ip: u32,
    pub mask: u32,
    pub gw: u32,
    pub dns1: u32,
    pub dns2: u32,
}
pub type wifi_mgmr_ipgot_msg_t = wifi_mgmr_ipgot_msg;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_ap_msg {
    pub channel: i32,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub hidden_ssid: u8,
    pub ssid_len: u32,
    pub psk: [crate::binary::c_types::c_char; 64usize],
    pub psk_tail: [crate::binary::c_types::c_char; 1usize],
    pub psk_len: u32,
}
pub type wifi_mgmr_ap_msg_t = wifi_mgmr_ap_msg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_profile {
    pub ssid_len: u16,
    pub psk_len: u16,
    pub pmk_len: u16,
    pub mac: [u8; 6usize],
    pub ssid: [crate::binary::c_types::c_char; 33usize],
    pub psk: [crate::binary::c_types::c_char; 65usize],
    pub pmk: [crate::binary::c_types::c_char; 65usize],
    pub band: u8,
    pub freq: u16,
    pub priority: u8,
    pub isActive: u8,
    pub isUsed: u8,
}
pub type wifi_mgmr_profile_t = wifi_mgmr_profile;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_cipher_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_mgmr_cipher_t {
    #[inline]
    pub fn wep40(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep40(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wep104(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep104(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tkip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tkip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccmp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ccmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep40: u8,
        wep104: u8,
        tkip: u8,
        ccmp: u8,
        rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep40: u8 = unsafe { ::core::mem::transmute(wep40) };
            wep40 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wep104: u8 = unsafe { ::core::mem::transmute(wep104) };
            wep104 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tkip: u8 = unsafe { ::core::mem::transmute(tkip) };
            tkip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ccmp: u8 = unsafe { ::core::mem::transmute(ccmp) };
            ccmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsvd: u8 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_scan_item {
    pub timestamp_lastseen: u32,
    pub ssid_len: u16,
    pub channel: u8,
    pub rssi: i8,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub ssid_tail: [crate::binary::c_types::c_char; 1usize],
    pub bssid: [u8; 6usize],
    pub ppm_abs: i8,
    pub ppm_rel: i8,
    pub auth: u8,
    pub cipher: u8,
    pub is_used: u8,
}
pub type wifi_mgmr_scan_item_t = wifi_mgmr_scan_item;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlan_netif {
    pub mode: crate::binary::c_types::c_int,
    pub vif_index: u8,
    pub mac: [u8; 6usize],
    pub dhcp_started: u8,
    pub __bindgen_anon_1: wlan_netif__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wlan_netif__bindgen_ty_1 {
    pub sta: wlan_netif__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wlan_netif__bindgen_ty_1__bindgen_ty_1 {
    pub rssi: i8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_connect_ind_stat_info {
    pub status_code: u16,
    pub chan_freq: u16,
    pub ssid: [crate::binary::c_types::c_char; 32usize],
    pub psk: [crate::binary::c_types::c_char; 65usize],
    pub bssid: [u8; 6usize],
    pub type_ind: u8,
    pub chan_band: u8,
}
pub type wifi_mgmr_connect_ind_stat_info_t = wifi_mgmr_connect_ind_stat_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_sta_basic_info {
    pub sta_idx: u8,
    pub is_used: u8,
    pub sta_mac: [u8; 6usize],
    pub tsfhi: u32,
    pub tsflo: u32,
    pub rssi: crate::binary::c_types::c_int,
    pub data_rate: u8,
}
pub type wifi_mgmr_sta_basic_info_t = wifi_mgmr_sta_basic_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr {
    pub channel: crate::binary::c_types::c_int,
    pub inf_ap_enabled: crate::binary::c_types::c_int,
    pub wlan_sta: wlan_netif,
    pub wlan_ap: wlan_netif,
    pub status: WIFI_MGMR_CONNECTION_STATUS_T,
    pub profiles: [wifi_mgmr_profile_t; 1usize],
    pub profile_active_index: crate::binary::c_types::c_int,
    pub scan_items: [wifi_mgmr_scan_item_t; 50usize],
    pub mq_f: *mut file,
    pub m: stateMachine,
    pub timer: crate::binary::c_types::c_int,
    pub wifi_mgmr_stat_info: wifi_mgmr_connect_ind_stat_info_t,
    pub ready: u8,
    pub country_code: [crate::binary::c_types::c_char; 3usize],
    pub disable_autoreconnect: u8,
    pub channel_nums: crate::binary::c_types::c_int,
    pub pending_task: u32,
    pub features: u32,
    pub scan_item_timeout: crate::binary::c_types::c_int,
    pub hostname: [crate::binary::c_types::c_char; 32usize],
}
pub type wifi_mgmr_t = wifi_mgmr;
extern "C" {
    pub fn wifi_mgmr_event_notify(msg: *mut wifi_mgmr_msg_t) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_state_get_internal(
        state: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_clean_internal() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_status_code_get_internal(
        s_code: *mut crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_set_country_code_internal(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_cnt_get_internal(sta_cnt: *mut u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_info_get_internal(
        sta_info_internal: *mut wifi_mgmr_sta_basic_info_t,
        idx: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_ap_sta_delete_internal(sta_idx: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_scan_complete_notify() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub static mut wifiMgmr: wifi_mgmr_t;
}
extern "C" {
    pub fn wifi_mgmr_auth_to_str(auth: u8) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wifi_mgmr_cipher_to_str(cipher: u8) -> *mut crate::binary::c_types::c_char;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_tsen_reload() -> crate::binary::c_types::c_int;
}
#[doc = " @file wifi_mgmr_api.h"]
#[doc = " Copyright (C) Bouffalo Lab 2016-2018"]
#[doc = ""]
#[doc = ""]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct wifi_mgmr_api_cipher_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl wifi_mgmr_api_cipher_t {
    #[inline]
    pub fn wep40(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep40(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wep104(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wep104(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tkip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tkip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccmp(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ccmp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        wep40: u8,
        wep104: u8,
        tkip: u8,
        ccmp: u8,
        rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wep40: u8 = unsafe { ::core::mem::transmute(wep40) };
            wep40 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wep104: u8 = unsafe { ::core::mem::transmute(wep104) };
            wep104 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tkip: u8 = unsafe { ::core::mem::transmute(tkip) };
            tkip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ccmp: u8 = unsafe { ::core::mem::transmute(ccmp) };
            ccmp as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsvd: u8 = unsafe { ::core::mem::transmute(rsvd) };
            rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn wifi_mgmr_api_common_msg(
        ev: WIFI_MGMR_EVENT_T,
        data1: *mut crate::binary::c_types::c_void,
        data2: *mut crate::binary::c_types::c_void,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_connect(
        ssid: *mut crate::binary::c_types::c_char,
        psk: *mut crate::binary::c_types::c_char,
        pmk: *mut crate::binary::c_types::c_char,
        mac: *mut u8,
        band: u8,
        freq: u16,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_cfg_req(
        ops: u32,
        task: u32,
        element: u32,
        type_: u32,
        length: u32,
        buf: *mut u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ip_got(
        ip: u32,
        mask: u32,
        gw: u32,
        dns1: u32,
        dns2: u32,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ip_update() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_reconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_rate_config(config: u16) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_conf_max_sta(max_sta_supported: u8) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ifaceup() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_sniffer_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ap_start(
        ssid: *mut crate::binary::c_types::c_char,
        passwd: *mut crate::binary::c_types::c_char,
        channel: crate::binary::c_types::c_int,
        hidden_ssid: u8,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_ap_stop() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_idle() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_channel_set(
        channel: crate::binary::c_types::c_int,
        use_40Mhz: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_raw_send(
        pkt: *mut u8,
        len: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_set_country_code(
        country_code: *mut crate::binary::c_types::c_char,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_disconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_scan() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_fw_powersaving(
        mode: crate::binary::c_types::c_int,
    ) -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_disable_autoreconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_enable_autoreconnect() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_denoise_enable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_denoise_disable() -> crate::binary::c_types::c_int;
}
extern "C" {
    pub fn wifi_mgmr_api_scan_item_beacon(
        channel: u8,
        rssi: i8,
        auth: u8,
        mac: *mut u8,
        ssid: *mut u8,
        len: crate::binary::c_types::c_int,
        ppm_abs: i8,
        ppm_rel: i8,
        cipher: u8,
    ) -> crate::binary::c_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub _address: u8,
}
